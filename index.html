<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Shark Byte</title>
  <style>
    *, ::before, ::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #000510;
      font-family: 'Courier New', Courier, monospace;
      color: #00ffcc;
      user-select: none;
    }

    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none; /* 让鼠标事件穿透到 Canvas */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
      box-sizing: border-box;
      text-shadow: 0 0 10px #00ffcc;
    }

    #indicators-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1; /* 在 UI 下层，但在游戏上层 */
      overflow: hidden;
    }

    .indicator {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 20px solid #ff3333;
      filter: drop-shadow(0 0 5px #ff3333);
      transform-origin: center center;
      display: none; /* 默认隐藏 */
    }

    .cable-indicator {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 16px solid #00ffcc;
      filter: drop-shadow(0 0 3px #00ffcc);
      transform-origin: center center;
      display: none; /* 默认隐藏 */
    }

    .hud-top {
      display: flex;
      justify-content: space-between;
      font-size: 24px;
      font-weight: bold;
    }

    .health-bar-container {
      width: 300px;
      height: 20px;
      border: 2px solid #ff3333;
      background: rgba(0, 0, 0, 0.5);
    }

    #health-fill {
      width: 100%;
      height: 100%;
      background-color: #ff3333;
      box-shadow: 0 0 10px #ff3333;
      transition: width 0.2s;
    }

    .stamina-bar-container {
      width: 300px;
      height: 20px;
      border: 2px solid #00ff00;
      background: rgba(0, 0, 0, 0.5);
    }

    #stamina-fill {
      width: 100%;
      height: 100%;
      background-color: #00ff00;
      box-shadow: 0 0 10px #00ff00;
      transition: width 0.2s;
    }

    #score-display {
      color: #ccff00;
      text-shadow: 0 0 10px #ccff00;
    }

    #message-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: auto; /* 允许点击按钮 */
    }

    h1 {
      font-size: 60px;
      margin: 0 0 20px 0;
      background: linear-gradient(to bottom, #00ffcc, #0055aa);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 10px rgba(0, 255, 204, 0.5));
    }

    p {
      font-size: 18px;
      color: #aaa;
      margin-bottom: 30px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    button {
      background: transparent;
      border: 2px solid #00ffcc;
      color: #00ffcc;
      padding: 15px 40px;
      font-size: 24px;
      font-family: inherit;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.3s;
      box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
    }

    button:hover {
      background: #00ffcc;
      color: #000;
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
    }

    #damage-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s;
      z-index: 3;
    }

    .key {
      display: inline-block;
      border: 1px solid #fff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      margin: 0 2px;
    }

    .settings-panel {
      margin-top: 20px;
      background: rgba(0, 20, 40, 0.8);
      padding: 15px;
      border: 1px solid #00ffcc;
      border-radius: 8px;
      text-align: left;
      width: 300px;
      margin-left: auto;
      margin-right: auto;
    }

    .setting-item {
      margin-bottom: 10px;
    }

    .setting-item label {
      display: block;
      margin-bottom: 5px;
      color: #00ffcc;
      font-size: 16px;
    }

    .setting-item input[type='range'] {
      width: 100%;
      accent-color: #00ffcc;
      cursor: pointer;
    }

    /* 暂停菜单样式 */
    #pause-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 5, 16, 0.85);
      backdrop-filter: blur(10px);
      z-index: 10;
      display: none; /* 默认隐藏 */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      pointer-events: auto;
    }

    #pause-menu h2 {
      font-size: 48px;
      color: #00ffcc;
      margin-bottom: 30px;
      text-shadow: 0 0 15px #00ffcc;
      letter-spacing: 5px;
    }

    .pause-content {
      display: flex;
      gap: 40px;
      align-items: flex-start;
    }

    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 250px;
    }

    .pause-info {
      width: 300px;
      text-align: left;
      background: rgba(0, 20, 40, 0.6);
      padding: 20px;
      border: 1px solid #00ffcc;
      border-radius: 8px;
      color: #ddd;
    }

    .pause-info h3 {
      color: #00ffcc;
      margin-top: 0;
      border-bottom: 1px solid #00ffcc;
      padding-bottom: 5px;
    }

    .pause-info p {
      font-size: 14px;
      background: none;
      padding: 0;
      margin-bottom: 10px;
      color: #ccc;
    }

    .pause-settings {
      margin-top: 20px;
      border-top: 1px solid #334455;
      padding-top: 10px;
    }

    /* 移动端适配 */
    @media screen and (max-width: 768px) {
      #ui-layer {
        padding: 10px;
      }

      .hud-top {
        font-size: 16px;
        flex-direction: column;
        gap: 10px;
      }

      #score-display {
        font-size: 18px;
        order: 2;
      }

      .health-bar-container,
      .stamina-bar-container {
        width: 100%;
        max-width: 200px;
        height: 16px;
      }

      .hud-top > div:last-child {
        order: 1;
        width: 100%;
        max-width: 200px;
      }

      h1 {
        font-size: 36px;
      }

      p {
        font-size: 14px;
      }

      button {
        padding: 12px 30px;
        font-size: 18px;
      }

      .settings-panel {
        width: 90%;
        max-width: 280px;
      }

      .pause-content {
        flex-direction: column;
        gap: 20px;
        align-items: center;
      }

      .pause-buttons {
        width: 90%;
        max-width: 250px;
      }

      .pause-info {
        width: 90%;
        max-width: 280px;
      }

      #pause-menu h2 {
        font-size: 32px;
      }
    }

    @media screen and (max-width: 480px) {
      .hud-top {
        font-size: 14px;
      }

      #score-display {
        font-size: 16px;
      }

      .health-bar-container,
      .stamina-bar-container {
        max-width: 150px;
        height: 14px;
      }

      .hud-top > div:last-child {
        max-width: 150px;
      }

      h1 {
        font-size: 28px;
      }

      p {
        font-size: 12px;
      }

      button {
        padding: 10px 24px;
        font-size: 16px;
      }
    }
  </style>
  <!-- 通过 CDN 引入 Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<div id="game-container"></div>
<div id="damage-overlay"></div>
<div id="indicators-container"></div>

<div id="ui-layer">
  <div class="hud-top">
    <div id="score-display">断网进度: 0 TB</div>
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        血量:
        <div class="health-bar-container">
          <div id="health-fill"></div>
        </div>
      </div>
      <div>
        耐力:
        <div class="stamina-bar-container">
          <div id="stamina-fill"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="message-center">
    <h1>Shark Byte</h1>
    <p>
      任务：摧毁海底光缆。<br />
      <span id="control-instruction">
        控制：鼠标移动瞄准，<br />
        <span class="key">左键</span> 冲刺/咬碎，<span class="key">右键</span> 后视镜。<span class="key">P</span>
        暂停。
      </span><br />
      警告：检测到云服务防御系统 (AWS, Azure, GCP)。
    </p>
    <button id="start-btn">开始潜入</button>

    <div class="settings-panel">
      <div class="setting-item">
        <label for="bgm-slider">BGM Volume</label>
        <input type="range" id="bgm-slider" min="0" max="1" step="0.01" value="0.8" />
      </div>
      <div class="setting-item">
        <label for="sfx-slider">SFX Volume</label>
        <input type="range" id="sfx-slider" min="0" max="1" step="0.01" value="0.8" />
      </div>
    </div>
  </div>
</div>

<div id="pause-menu">
  <h2>PAUSED</h2>
  <div class="pause-content">
    <div class="pause-buttons">
      <button id="resume-btn">继续游戏</button>
      <button id="restart-btn-pause">重新开始</button>
      <button id="exit-fullscreen-btn">退出全屏</button>
    </div>
    <div class="pause-info">
      <h3>操作说明</h3>
      <p id="pause-control-instruction">移动鼠标: 瞄准方向<br><span class="key">左键</span>: 冲刺 / 咬碎光缆<br><span
        class="key">右键</span>: 后视镜<br><span class="key">P</span>: 暂停</p>

      <h3>游戏规则</h3>
      <p>摧毁海底光缆以切断网络连接。</p>
      <p>躲避或摧毁云服务防御无人机。</p>

      <div class="pause-settings">
        <div class="setting-item">
          <label for="bgm-slider-pause">BGM Volume</label>
          <input type="range" id="bgm-slider-pause" min="0" max="1" step="0.01" value="0.8" />
        </div>
        <div class="setting-item">
          <label for="sfx-slider-pause">SFX Volume</label>
          <input type="range" id="sfx-slider-pause" min="0" max="1" step="0.01" value="0.8" />
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  // === 移动设备检测 ===
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)

  // === 游戏配置 ===
  const CONFIG = {
    sharkSpeed: 0.4,
    boostSpeed: 1,
    turnSpeed: 0.1, // 平滑速度
    mouseSensitivity: 0.004, // 灵敏度 (桌面)
    gyroSensitivity: 0.03, // 陀螺仪灵敏度 (移动)
    cameraDistance: 15,
    rollFactor: 0.2, // 侧倾系数
    fogColor: 0x001020,
    maxHealth: 100,
    maxStamina: 100,
    recoverHealth: 5, // 咬断电缆恢复的生命
    staminaDrainRate: 0.4, // 每帧消耗
    staminaRecoverRate: 0.2, // 每帧恢复
    minStaminaToBoost: 1, // 最低冲刺需求
    recoverStamina: 40, // 咬断电缆恢复的耐力
    enemyRemoveDistance: 200, // 敌人超过此距离后删除
    enemySpeedAWS: 0.5, // AWS 敌人移动速度
    enemySpeedAzure: 0.6, // Azure 敌人移动速度
    enemySpeedGCP: 0.6, // GCP 敌人移动速度
    colors: {
      shark: 0x667788,
      cable: 0x00ffcc, // 霓虹蓝
      cableCore: 0xffffff,
      aws: 0xff9900, // 橙色
      azure: 0x007fff, // 蓝色
      gcp: 0xea4335, // 红色
    },
  }

  // === 状态变量 ===
  let gameState = {
    isPlaying: false,
    isPaused: false,
    cableCount: 3,
    score: 0,
    cablesCut: 0, // 记录切断电缆数量
    health: CONFIG.maxHealth,
    stamina: CONFIG.maxStamina,
    time: 0,
  }

  // === Three.js 全局变量 ===
  let scene, camera, renderer
  let sharkContainer, sharkMesh, sharkJaw

  // 用于累积旋转的角度变量
  let sharkEuler = { x: 0, y: 0 }

  let targetRotation = new THREE.Quaternion() // 用于 Slerp 的目标四元数
  let cables = []
  let enemies = []
  let particles = []
  let explosions = [] // 爆炸特效数组
  let isBoosting = false
  let isLookingBack = false // 观察身后状态
  let clock = new THREE.Clock()

  // 陀螺仪相关变量
  let gyroAlpha = 0 // 设备方向 (Z轴旋转)
  let gyroBeta = 0  // 设备俯仰 (X轴旋转)
  let gyroGamma = 0 // 设备侧倾 (Y轴旋转)
  let gyroInitialized = false
  let initialAlpha = 0
  let initialBeta = 0
  let initialGamma = 0

  // 帧率控制变量
  const fpsLimit = 60
  const fpsInterval = 1000 / fpsLimit
  let lastFrameTime = performance.now()

  // 界面元素
  const uiScore = document.getElementById('score-display')
  const uiHealth = document.getElementById('health-fill')
  const uiStamina = document.getElementById('stamina-fill')
  const uiMessage = document.getElementById('message-center')
  const startBtn = document.getElementById('start-btn')
  const bgmSlider = document.getElementById('bgm-slider')
  const sfxSlider = document.getElementById('sfx-slider')
  const damageOverlay = document.getElementById('damage-overlay')
  const indicatorsContainer = document.getElementById('indicators-container')

  // 暂停菜单元素
  const pauseMenu = document.getElementById('pause-menu')
  const resumeBtn = document.getElementById('resume-btn')
  const restartBtnPause = document.getElementById('restart-btn-pause')
  const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn')
  const bgmSliderPause = document.getElementById('bgm-slider-pause')
  const sfxSliderPause = document.getElementById('sfx-slider-pause')

  // 初始化
  function init() {
    // 场景
    scene = new THREE.Scene()
    scene.fog = new THREE.FogExp2(CONFIG.fogColor, 0.01)
    scene.background = new THREE.Color(CONFIG.fogColor)

    // 摄像机
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200)

    // 渲染器
    renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    document.getElementById('game-container').appendChild(renderer.domElement)

    // 灯光
    const ambientLight = new THREE.AmbientLight(0x404040, 2) // 环境光
    scene.add(ambientLight)

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8)
    dirLight.position.set(10, 50, 20)
    dirLight.castShadow = true
    scene.add(dirLight)

    // 聚光灯（模拟鲨鱼头灯/海底光线）
    const spotLight = new THREE.SpotLight(0x00ffff, 1)
    spotLight.position.set(0, 10, 0)
    spotLight.angle = Math.PI / 4
    spotLight.penumbra = 0.1
    scene.add(spotLight)

    // 创建游戏对象
    createEnvironment()
    createShark()
    generateCables()

    // 事件监听
    window.addEventListener('resize', onWindowResize, false)

    if (isMobile) {
      // 移动端：使用触摸和陀螺仪
      document.addEventListener('touchstart', onTouchStart)
      document.addEventListener('touchend', onTouchEnd)
      window.addEventListener('deviceorientation', onDeviceOrientation, false)
      // 更新UI提示
      document.getElementById('control-instruction').innerHTML = '控制：倾斜设备瞄准，<br />按住屏幕冲刺/咬碎。'
      document.getElementById('pause-control-instruction').innerHTML = '倾斜设备: 瞄准方向<br>按住屏幕: 冲刺 / 咬碎光缆'
    } else {
      // 桌面端：使用鼠标
      document.addEventListener('mousemove', onMouseMoveInfinite, false)
      document.addEventListener('mousedown', onMouseDown, false)
      document.addEventListener('mouseup', onMouseUp, false)
      // 监听指针锁定状态变化
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== document.body && gameState.isPlaying) {
          togglePause(true)
        }
      })
    }

    document.addEventListener('contextmenu', (e) => e.preventDefault(), false)

    startBtn.addEventListener(isMobile ? 'touchstart' : 'click', startGame)

    bgmSlider.addEventListener('input', (e) => {
      const volume = parseFloat(e.target.value)
      soundManager.setBGMVolume(volume)
      bgmSliderPause.value = e.target.value // 同步
    })

    sfxSlider.addEventListener('input', (e) => {
      const volume = parseFloat(e.target.value)
      soundManager.setSFXVolume(volume)
      sfxSliderPause.value = e.target.value // 同步
    })

    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyP') {
        togglePause(true)
      }
    })

    resumeBtn.addEventListener(isMobile ? 'touchstart' : 'click', () => togglePause(false))

    restartBtnPause.addEventListener(isMobile ? 'touchstart' : 'click', () => {
      togglePause(false)
      startGame()
    })

    exitFullscreenBtn.addEventListener(isMobile ? 'touchstart' : 'click', () => {
      if (document.fullscreenElement) {
        document.exitFullscreen()
      }
    })

    bgmSliderPause.addEventListener('input', (e) => {
      soundManager.setBGMVolume(parseFloat(e.target.value))
      bgmSlider.value = e.target.value // 与主菜单同步
    })

    sfxSliderPause.addEventListener('input', (e) => {
      soundManager.setSFXVolume(parseFloat(e.target.value))
      sfxSlider.value = e.target.value // 与主菜单同步
    })

    // 提前初始化音效管理器以启用音量控制
    soundManager.init()
    soundManager.setBGMVolume(parseFloat(bgmSlider.value))
    soundManager.setSFXVolume(parseFloat(sfxSlider.value))

    // 开始循环
    animate()
  }

  // === 核心逻辑：创建鲨鱼（低多边形风格）===
  function createShark() {
    sharkContainer = new THREE.Group()
    scene.add(sharkContainer)

    // 身体
    const bodyGeo = new THREE.ConeGeometry(1, 4, 8)
    bodyGeo.rotateX(Math.PI / 2) // 让圆锥躺下，指向 Z 轴（Three.js 默认朝向）
    const bodyMat = new THREE.MeshPhongMaterial({ color: CONFIG.colors.shark, flatShading: true })
    sharkMesh = new THREE.Mesh(bodyGeo, bodyMat)
    sharkMesh.castShadow = true
    sharkContainer.add(sharkMesh)

    // 尾巴
    const tailGeo = new THREE.BoxGeometry(0.1, 1.3, 1.2)
    tailGeo.translate(0, 0, 2.2)
    const tail = new THREE.Mesh(tailGeo, bodyMat)
    sharkMesh.add(tail)

    // 鳍
    const finGeo = new THREE.BufferGeometry()
    const finVertices = new Float32Array([0, 0.5, -0.5, 0, 0.5, 0.5, 0, 2.0, 0.5])
    finGeo.setAttribute('position', new THREE.BufferAttribute(finVertices, 3))
    finGeo.computeVertexNormals()
    const fin = new THREE.Mesh(finGeo, bodyMat)
    fin.material.side = THREE.DoubleSide
    sharkMesh.add(fin)

    // 眼
    const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8)
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 })
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat)
    eyeL.position.set(0.5, 0.3, -3)
    sharkMesh.add(eyeL)
    const eyeR = eyeL.clone()
    eyeR.position.set(-0.5, 0.3, -3)
    sharkMesh.add(eyeR)

    // 嘴
    const jawGeo = new THREE.ConeGeometry(0.8, 2, 8)
    jawGeo.rotateX(-Math.PI / 2)
    sharkJaw = new THREE.Mesh(jawGeo, new THREE.MeshPhongMaterial({ color: 0x333333, flatShading: true }))
    sharkJaw.position.set(0, 0, -3.4)
    sharkJaw.scale.set(1.4, 1.2, 1.4)
    sharkMesh.add(sharkJaw)
  }

  // === 核心逻辑：创建海底光缆 ===
  function generateCables() {
    cables.forEach((c) => {
      scene.remove(c.mesh)
      // 清理指示器元素
      if (c.indicatorEl) {
        c.indicatorEl.remove()
      }
    })
    cables = []

    // 确定电缆的生成参考点。如果正在游戏，则使用鲨鱼的当前位置，否则使用原点。
    const refPosition = gameState.isPlaying ? sharkContainer.position.clone() : new THREE.Vector3(0, 0, 0)

    for (let i = 0; i < gameState.cableCount; i++) {
      // 传入参考位置，使新电缆生成在鲨鱼前方
      spawnCable(refPosition)
    }
    // 电缆数量增加
    gameState.cableCount += 1
  }

  function spawnCable(refPosition) {
    const pathPoints = []

    // 确保新电缆刷新在鲨鱼前方，并且位置是随机散布的
    const spawnDistance = 150 // 新电缆距离鲨鱼的大致距离
    // 获取鲨鱼的前进方向（Z 轴负方向，以世界坐标系表示）
    const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(sharkContainer.quaternion)

    // 1. 计算基本生成点（鲨鱼位置 + 前方距离）
    let basePos = refPosition.clone().add(forwardVector.clone().multiplyScalar(spawnDistance))

    // 2. 计算侧向和垂直的随机偏移（确保散布在鲨鱼的视野周围）
    const upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(sharkContainer.quaternion)
    const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(sharkContainer.quaternion)

    // 侧向 +/- 50
    basePos.add(rightVector.clone().multiplyScalar((Math.random() - 0.5) * 100))
    // 垂直 +/- 30
    basePos.add(upVector.clone().multiplyScalar((Math.random() - 0.5) * 60))

    // 3. 增加沿前进方向的随机抖动
    basePos.add(forwardVector.clone().multiplyScalar((Math.random() - 0.5) * 50))

    let currentPos = basePos.clone()

    for (let j = 0; j < 20; j++) {
      pathPoints.push(currentPos.clone())
      // 让电缆的路径保持随机蜿蜒的特性
      currentPos.x += (Math.random() - 0.5) * 30
      currentPos.y += (Math.random() - 0.5) * 10
      currentPos.z -= Math.random() * 40 + 20
    }

    const curve = new THREE.CatmullRomCurve3(pathPoints)
    const geometry = new THREE.TubeGeometry(curve, 64, 0.3, 8, false)
    const material = new THREE.MeshStandardMaterial({
      color: 0x222222,
      emissive: CONFIG.colors.cable,
      emissiveIntensity: 2,
      roughness: 0.4,
      metalness: 0.8,
    })

    const mesh = new THREE.Mesh(geometry, material)
    scene.add(mesh)

    const points = curve.getPoints(50)

    // 创建光缆指示器元素
    const indicatorEl = document.createElement('div')
    indicatorEl.className = 'cable-indicator'
    indicatorsContainer.appendChild(indicatorEl)

    cables.push({
      mesh: mesh,
      curve: curve,
      points: points,
      active: true,
      indicatorEl: indicatorEl,
    })
  }

  // === 环境粒子 ===
  function createEnvironment() {
    const partGeo = new THREE.BufferGeometry()
    const partCount = 500
    const posArray = new Float32Array(partCount * 3)
    for (let i = 0; i < partCount * 3; i++) {
      posArray[i] = (Math.random() - 0.5) * 200
    }
    partGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3))
    const partMat = new THREE.PointsMaterial({
      size: 0.5,
      color: 0x88aaff,
      transparent: true,
      opacity: 0.6,
    })
    const particleSystem = new THREE.Points(partGeo, partMat)
    scene.add(particleSystem)
    particles.push(particleSystem)
  }

  // === 爆炸特效 ===
  function createExplosion(position) {
    const particleCount = 50
    const geometry = new THREE.BufferGeometry()
    const positions = []
    const velocities = []

    for (let i = 0; i < particleCount; i++) {
      positions.push(position.x, position.y, position.z)
      // 随机向四周扩散的速度
      velocities.push((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3)
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3))

    const material = new THREE.PointsMaterial({
      color: 0xff5500, // 爆炸橙红色
      size: 0.5,
      transparent: true,
      opacity: 1,
      blending: THREE.AdditiveBlending,
    })

    const explosionMesh = new THREE.Points(geometry, material)
    scene.add(explosionMesh)

    explosions.push({
      mesh: explosionMesh,
      velocities: velocities,
      age: 0,
      maxAge: 60, // 持续帧数
    })
  }

  function createLabel(text) {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    const fontSize = 40
    ctx.font = `bold ${fontSize}px "Courier New"`
    const textMetrics = ctx.measureText(text)
    const textWidth = textMetrics.width

    canvas.width = textWidth + 20
    canvas.height = fontSize + 20

    // 调整画布大小后重新设置字体
    ctx.font = `bold ${fontSize}px "Courier New"`
    ctx.fillStyle = '#ff3333'
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'
    ctx.shadowColor = '#ff3333'
    ctx.shadowBlur = 5
    ctx.fillText(text, canvas.width / 2, canvas.height / 2)

    const texture = new THREE.CanvasTexture(canvas)
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true })
    const sprite = new THREE.Sprite(material)
    // 缩放精灵到合理的世界单位大小
    sprite.scale.set(canvas.width / 60, canvas.height / 60, 1)
    return sprite
  }

  // === 敌人生成逻辑 ===
  function spawnEnemy() {
    if (!gameState.isPlaying) return

    const typeRand = Math.random()
    let type = 'aws'
    if (typeRand > 0.7) type = 'azure'
    if (typeRand > 0.9) type = 'gcp'

    const sharkDir = new THREE.Vector3()
    sharkContainer.getWorldDirection(sharkDir)
    sharkDir.normalize()

    const spawnDist = 60 + Math.random() * 20
    const spawnBase = sharkContainer.position.clone().add(sharkDir.multiplyScalar(spawnDist))

    const offset = new THREE.Vector3(
      (Math.random() - 0.5) * 60,
      (Math.random() - 0.5) * 40,
      (Math.random() - 0.5) * 20,
    )
    const spawnPos = spawnBase.add(offset)

    let geo, mat, speed, damage, labelText

    if (type === 'aws') {
      geo = new THREE.BoxGeometry(2, 2, 2)
      mat = new THREE.MeshPhongMaterial({ color: CONFIG.colors.aws, emissive: 0xff6600, emissiveIntensity: 0.5 })
      speed = CONFIG.enemySpeedAWS
      damage = 10
      labelText = 'AWS Enforcer'
    } else if (type === 'azure') {
      geo = new THREE.TetrahedronGeometry(1.5)
      mat = new THREE.MeshPhongMaterial({ color: CONFIG.colors.azure, emissive: 0x0000ff, emissiveIntensity: 0.5 })
      speed = CONFIG.enemySpeedAzure
      damage = 5
      labelText = 'Azure Sentinel'
    } else {
      geo = new THREE.IcosahedronGeometry(1.2, 1)
      mat = new THREE.MeshPhongMaterial({ color: CONFIG.colors.gcp, wireframe: true, emissive: 0xffffff })
      speed = CONFIG.enemySpeedGCP
      damage = 20
      labelText = 'GCP Guardian'
    }

    const group = new THREE.Group()
    group.position.copy(spawnPos)

    const mesh = new THREE.Mesh(geo, mat)
    group.add(mesh)

    const label = createLabel(labelText)
    label.position.set(0, 2.5, 0) // 将标签放置在无人机上方
    group.add(label)

    scene.add(group)

    const indicatorEl = document.createElement('div')
    indicatorEl.className = 'indicator'
    indicatorsContainer.appendChild(indicatorEl)

    enemies.push({
      group: group, // 存储组而不是网格
      mesh: mesh, // 保留对网格的引用用于旋转
      type: type,
      speed: speed,
      damage: damage,
      life: 100,
      indicatorEl: indicatorEl,
    })
  }

  // === 陀螺仪权限请求 ===
  async function requestGyroPermission() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const permission = await DeviceOrientationEvent.requestPermission()
        if (permission === 'granted') {
          console.log('陀螺仪权限已授予')
          return true
        } else {
          console.warn('陀螺仪权限被拒绝')
          return false
        }
      } catch (error) {
        console.error('请求陀螺仪权限失败:', error)
        return false
      }
    }
    return true
  }

  // === 屏幕方向锁定 ===
  async function lockOrientation() {
    try {
      if (screen.orientation && screen.orientation.lock) {
        await screen.orientation.lock('landscape')
        return true
      }
    } catch (error) {
      console.log('屏幕方向锁定不支持或失败:', error)
      return false
    }
  }

  // === 陀螺仪输入处理 ===
  function onDeviceOrientation(event) {
    if (!gameState.isPlaying || gameState.isPaused) return

    const alpha = event.alpha || 0  // Z轴 (0-360)
    const beta = event.beta || 0    // X轴 (-180 to 180)
    const gamma = event.gamma || 0  // Y轴 (-90 to 90)

    // 初始化基准值
    if (!gyroInitialized) {
      initialAlpha = alpha
      initialBeta = beta
      initialGamma = gamma
      gyroInitialized = true
      return
    }

    // 计算相对旋转
    let deltaAlpha = alpha - initialAlpha
    let deltaBeta = beta - initialBeta
    let deltaGamma = gamma - initialGamma

    // 处理alpha的360度跳变
    if (deltaAlpha > 180) deltaAlpha -= 360
    if (deltaAlpha < -180) deltaAlpha += 360

    // 横屏模式下的映射：
    // gamma (设备左右倾斜) -> 控制偏航 (Y轴旋转)
    // beta (设备前后倾斜) -> 控制俯仰 (X轴旋转)

    sharkEuler.y = -deltaGamma * CONFIG.gyroSensitivity
    sharkEuler.x = (deltaBeta - 45) * CONFIG.gyroSensitivity * 0.5 // 调整基准角度

    // 限制俯仰角
    sharkEuler.x = Math.max(-1.4, Math.min(1.4, sharkEuler.x))
  }

  // === 触摸输入处理 ===
  function onTouchStart(event) {
    if (!gameState.isPlaying) return
    if (gameState.isPaused) return

    event.preventDefault()

    // 触摸开始冲刺
    if (gameState.stamina >= CONFIG.minStaminaToBoost) {
      isBoosting = true
      soundManager.playBoost()
    }
  }

  function onTouchEnd(event) {
    event.preventDefault()
    isBoosting = false
  }

  // === 输入处理（鼠标控制）===
  function onMouseMoveInfinite(event) {
    if (isLookingBack) return
    if (document.pointerLockElement === document.body && gameState.isPlaying) {
      // 累积偏航角（Y轴旋转）
      sharkEuler.y -= event.movementX * CONFIG.mouseSensitivity

      // 累积俯仰角（X轴旋转）- 鼠标上移 = 抬头（非反转控制）
      sharkEuler.x -= event.movementY * CONFIG.mouseSensitivity

      // 限制上下俯仰角度，防止翻个底朝天（限制在 -80度 到 80度）
      sharkEuler.x = Math.max(-1.4, Math.min(1.4, sharkEuler.x))
    }
  }

  function onMouseDown(event) {
    if (!gameState.isPlaying) return
    if (gameState.isPaused) return

    if (event.button === 2) {
      isLookingBack = true
      return
    }

    // 只在桌面端使用指针锁定
    if (!isMobile && document.pointerLockElement !== document.body) {
      document.body.requestPointerLock()
    }

    // 只有在耐力足够时才能冲刺
    if (gameState.stamina >= CONFIG.minStaminaToBoost) {
      isBoosting = true
      soundManager.playBoost()
    }
  }

  function onMouseUp(event) {
    if (event.button === 2) {
      isLookingBack = false
      return
    }
    isBoosting = false
  }

  function togglePause(pause) {
    if (!gameState.isPlaying) return // 如果没有游戏则无法暂停

    gameState.isPaused = pause

    if (gameState.isPaused) {
      pauseMenu.style.display = 'flex'
      if (!isMobile) {
        document.exitPointerLock()
      }
      // 打开暂停菜单时同步滑块
      bgmSliderPause.value = bgmSlider.value
      sfxSliderPause.value = sfxSlider.value
    } else {
      pauseMenu.style.display = 'none'
      if (!isMobile) {
        document.body.requestPointerLock()
      }
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  // === 游戏逻辑 ===
  async function startGame() {
    // 移动端处理
    if (isMobile) {
      // 请求陀螺仪权限
      const gyroPermission = await requestGyroPermission()
      console.log(gyroPermission)
      if (!gyroPermission) {
        window.confirm('陀螺仪不可用，无法开始游戏！')
        return
      }
      // 重置陀螺仪状态
      gyroInitialized = false
      // 锁定横屏
      const lock = await lockOrientation()
      if (!lock) {
        window.confirm('屏幕方向锁定失败，无法开始游戏！')
        return
      }
      // 尝试全屏
      if (document.documentElement.requestFullscreen) {
        await document.documentElement.requestFullscreen()
        console.log('全屏成功')
      }
    } else {
      // 桌面端处理
      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen()
        }
      } catch (e) {
        console.log('全屏请求被拒绝或不支持')
      }

      document.body.requestPointerLock().catch((err) => {console.error(err)})
    }

    console.log('初始化音效和游戏状态...')
    soundManager.playBGM()

    gameState.isPlaying = true
    gameState.isPaused = false
    gameState.score = 0
    gameState.cablesCut = 0
    gameState.health = 100
    gameState.stamina = 100
    uiMessage.style.display = 'none'

    sharkContainer.position.set(0, 0, 0)
    // 重置旋转使用四元数
    sharkContainer.quaternion.identity()
    sharkEuler = { x: 0, y: 0 }

    enemies.forEach((e) => {
      scene.remove(e.group)
      if (e.indicatorEl) e.indicatorEl.remove()
    })
    enemies = []

    // 清理现有光缆指示器
    cables.forEach((c) => {
      if (c.indicatorEl) c.indicatorEl.remove()
    })

    // 初始生成电缆
    generateCables()
    updateHUD()
  }

  function gameOver() {
    soundManager.playGameOver()
    gameState.isPlaying = false
    document.exitPointerLock()
    uiMessage.style.display = 'block'
    document.querySelector('#message-center h1').innerText = '连接断开'
    document.querySelector(
      '#message-center p',
    ).innerHTML = `任务失败。<br>你切断了 ${gameState.score} TB 的数据。`
    startBtn.innerText = '重新连接'
  }

  function takeDamage(amount) {
    gameState.health -= amount
    damageOverlay.style.opacity = '0.8'
    setTimeout(() => {
      damageOverlay.style.opacity = '0'
    }, 500)

    if (gameState.health <= 0) {
      gameState.health = 0
      gameOver()
    }
    updateHUD()
  }

  function updateHUD() {
    uiScore.innerText = `断网进度: ${gameState.score} TB`
    uiHealth.style.width = `${gameState.health}%`
    uiStamina.style.width = `${gameState.stamina}%`
  }

  function updateIndicators() {
    const width = window.innerWidth
    const height = window.innerHeight
    const widthHalf = width / 2
    const heightHalf = height / 2

    // 更新敌人指示器
    enemies.forEach((enemy) => {
      if (!enemy.indicatorEl) return

      const pos = enemy.group.position.clone()
      pos.project(camera)

      const isBehind = pos.z > 1
      const isOnScreen = pos.x > -0.9 && pos.x < 0.9 && pos.y > -0.9 && pos.y < 0.9 && !isBehind

      if (isOnScreen) {
        enemy.indicatorEl.style.display = 'none'
      } else {
        enemy.indicatorEl.style.display = 'block'

        let tx = pos.x
        let ty = pos.y

        if (isBehind) {
          tx = -tx
          ty = -ty
        }

        const angle = Math.atan2(ty, tx)
        const absX = Math.abs(tx)
        const absY = Math.abs(ty)

        let screenX, screenY

        if (absX > absY) {
          const scale = 0.9 / absX
          tx = (tx > 0 ? 1 : -1) * 0.9
          ty = ty * scale
        } else {
          const scale = 0.9 / absY
          ty = (ty > 0 ? 1 : -1) * 0.9
          tx = tx * scale
        }

        screenX = tx * widthHalf + widthHalf
        screenY = -(ty * heightHalf) + heightHalf

        enemy.indicatorEl.style.left = `${screenX}px`
        enemy.indicatorEl.style.top = `${screenY}px`

        const deg = (angle * 180) / Math.PI - 90
        enemy.indicatorEl.style.transform = `translate(-50%, -50%) rotate(${-deg}deg)`
      }
    })

    // 更新光缆指示器
    cables.forEach((cable) => {
      if (!cable.indicatorEl || !cable.active) return

      // 使用光缆的第一个点作为指示器目标位置
      const cablePos = cable.points[0].clone()
      cablePos.project(camera)

      const isBehind = cablePos.z > 1
      const isOnScreen = cablePos.x > -0.8 && cablePos.x < 0.8 && cablePos.y > -0.8 && cablePos.y < 0.8 && !isBehind

      if (isOnScreen) {
        cable.indicatorEl.style.display = 'none'
      } else {
        cable.indicatorEl.style.display = 'block'

        let tx = cablePos.x
        let ty = cablePos.y

        if (isBehind) {
          tx = -tx
          ty = -ty
        }

        const angle = Math.atan2(ty, tx)
        const absX = Math.abs(tx)
        const absY = Math.abs(ty)

        let screenX, screenY

        if (absX > absY) {
          const scale = 0.85 / absX
          tx = (tx > 0 ? 1 : -1) * 0.85
          ty = ty * scale
        } else {
          const scale = 0.85 / absY
          ty = (ty > 0 ? 1 : -1) * 0.85
          tx = tx * scale
        }

        screenX = tx * widthHalf + widthHalf
        screenY = -(ty * heightHalf) + heightHalf

        cable.indicatorEl.style.left = `${screenX}px`
        cable.indicatorEl.style.top = `${screenY}px`

        const deg = (angle * 180) / Math.PI - 90
        cable.indicatorEl.style.transform = `translate(-50%, -50%) rotate(${-deg}deg)`
      }
    })
  }

  // === 主循环 ===
  function animate(currentTime) {
    requestAnimationFrame(animate)

    if (!currentTime) currentTime = performance.now()
    const elapsed = currentTime - lastFrameTime
    if (elapsed < fpsInterval) return
    lastFrameTime = currentTime - (elapsed % fpsInterval)

    const time = clock.getElapsedTime()

    if (!gameState.isPlaying) {
      scene.rotation.y = 0
      // 侧前方视角：X=28（右侧），Y=-20（上方），Z=-24（前方，鲨鱼面向-Z）
      camera.position.set(28, -20, -24)
      camera.lookAt(0, 0, 0)
      renderer.render(scene, camera)
      return
    } else {
      if (gameState.isPaused) {
        renderer.render(scene, camera) // 保持渲染静态帧
        return
      }
      scene.rotation.y = 0
    }

    // 1. 鲨鱼运动逻辑（更新）
    // 注意：陀螺仪在 onDeviceOrientation 中已更新 sharkEuler
    const targetPitch = sharkEuler.x
    const targetYaw = sharkEuler.y

    // 使用四元数 Slerp 进行平滑旋转

    // 1.1. 根据输入的俯仰角（X）和偏航角（Y）创建目标欧拉角
    // 使用 'YXZ' 顺序，这在飞行/自由移动控制中较为常用
    const targetEuler = new THREE.Euler(targetPitch, targetYaw, 0, 'YXZ')
    targetRotation.setFromEuler(targetEuler)

    // 1.2. 计算侧倾（Roll）
    // 获取当前的偏航角值（通过将四元数转回欧拉角）
    const currentEuler = new THREE.Euler().setFromQuaternion(sharkContainer.quaternion, 'YXZ')
    // 计算目标偏航角和当前偏航角之间的差值（作为转向速度的近似）
    const yawDelta = targetYaw - currentEuler.y

    // 计算目标侧倾角：基于转向速度（yawDelta）。限制侧倾幅度在 -45度（0.78 rad）到 45度
    const targetRoll = Math.max(-0.78, Math.min(0.78, -yawDelta * 5 * CONFIG.rollFactor))

    // 1.3. 将侧倾（Z轴旋转）应用到目标四元数上
    // 创建一个只包含侧倾的四元数
    const rollQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, -1), targetRoll)
    // 将侧倾合并到目标旋转中
    targetRotation.multiply(rollQuaternion)

    // 1.4. 使用 Slerp 平滑插值当前的四元数到目标四元数
    sharkContainer.quaternion.slerp(targetRotation, CONFIG.turnSpeed)

    // 耐力系统：冲刺时消耗，不冲刺时恢复
    if (isBoosting && gameState.stamina > 0) {
      gameState.stamina -= CONFIG.staminaDrainRate
      if (gameState.stamina <= 0) {
        gameState.stamina = 0
        isBoosting = false // 耐力耗尽时停止冲刺
      }
      updateHUD() // 实时更新耐力条
    } else if (!isBoosting && gameState.stamina < CONFIG.maxStamina) {
      gameState.stamina += CONFIG.staminaRecoverRate
      if (gameState.stamina > CONFIG.maxStamina) {
        gameState.stamina = CONFIG.maxStamina
      }
      updateHUD() // 实时更新耐力条
    }

    // 如果耐力不足，强制停止冲刺
    if (isBoosting && gameState.stamina < CONFIG.minStaminaToBoost) {
      isBoosting = false
    }

    // 始终向前移动（沿自身的 Z 轴）
    const currentSpeed = isBoosting ? CONFIG.boostSpeed : CONFIG.sharkSpeed
    sharkContainer.translateZ(-currentSpeed)

    // 摄像机跟随（Lerp）
    let relativeCameraOffset
    let lookAtTarget

    if (isLookingBack) {
      // 侧前方: 右 8, 上 5, 前 20 (Z 为负是前)
      relativeCameraOffset = new THREE.Vector3(8, 5, -20)

      // 看向身后: 获取后方向量
      const backward = new THREE.Vector3(0, 0, 1).applyQuaternion(sharkContainer.quaternion)
      lookAtTarget = sharkContainer.position.clone().add(backward.multiplyScalar(20))
    } else {
      relativeCameraOffset = new THREE.Vector3(0, 5, CONFIG.cameraDistance)

      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(sharkContainer.quaternion)
      lookAtTarget = sharkContainer.position.clone().add(forward.multiplyScalar(10))
    }

    const cameraOffset = relativeCameraOffset.applyMatrix4(sharkContainer.matrixWorld)

    camera.position.lerp(cameraOffset, 0.1)
    camera.lookAt(lookAtTarget)

    // 尾巴摆动
    sharkMesh.children[0].rotation.y = Math.sin(time * (isBoosting ? 20 : 8)) * 0.5

    // 2. 光缆逻辑与碰撞
    const biteRadius = 5.0

    for (let i = cables.length - 1; i >= 0; i--) {
      const cable = cables[i]
      if (!cable.active) continue

      let hit = false
      let hitPoint = null
      for (let p of cable.points) {
        if (p.distanceTo(sharkContainer.position) < biteRadius) {
          hit = true
          hitPoint = p.clone()
          break
        }
      }

      if (hit && isBoosting) {
        gameState.score += 1024
        gameState.cablesCut++
        soundManager.playCut()
        createExplosion(hitPoint) // 触发爆炸特效

        // 恢复生命
        gameState.health += CONFIG.recoverHealth
        if (gameState.health > CONFIG.maxHealth) {
          gameState.health = CONFIG.maxHealth
        }

        // 恢复耐力
        gameState.stamina += CONFIG.recoverStamina
        if (gameState.stamina > CONFIG.maxStamina) {
          gameState.stamina = CONFIG.maxStamina
        }

        updateHUD()

        cable.mesh.material.emissive.setHex(0x000000)
        cable.mesh.material.color.setHex(0x333333)
        cable.mesh.position.y -= 1
        cable.active = false

        // 隐藏并清理光缆指示器
        if (cable.indicatorEl) {
          cable.indicatorEl.style.display = 'none'
        }
      }
    }

    // 所有电缆都被切断后，重新生成电缆组
    if (cables.every((c) => !c.active)) {
      generateCables() // 基于鲨鱼当前位置生成
      gameState.score += 5000
      updateHUD()
    }

    // 3. 敌人逻辑
    const spawnChance = 0.01 + gameState.cablesCut * 0.002

    if (Math.random() < spawnChance) {
      spawnEnemy()
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i]

      e.group.lookAt(sharkContainer.position)
      e.group.translateZ(e.speed)

      if (e.type === 'aws') e.mesh.rotation.z += 0.1
      if (e.type === 'azure') e.mesh.rotation.x += 0.1

      const dist = e.group.position.distanceTo(sharkContainer.position)

      if (dist < 2.5) {
        takeDamage(e.damage)
        soundManager.playDamage()
        scene.remove(e.group)
        if (e.indicatorEl) e.indicatorEl.remove()
        enemies.splice(i, 1)
        continue
      }

      if (dist > CONFIG.enemyRemoveDistance) {
        scene.remove(e.group)
        if (e.indicatorEl) e.indicatorEl.remove()
        enemies.splice(i, 1)
      }
    }

    // 4. 粒子动画
    particles.forEach((p) => {
      // 如果粒子系统离鲨鱼太远，则将其移到鲨鱼前方
      if (sharkContainer.position.distanceTo(p.position) > 200) {
        p.position.copy(sharkContainer.position)
        p.position.z -= 100
      }
      p.rotation.y += 0.001
    })

    // 5. 更新爆炸特效
    for (let i = explosions.length - 1; i >= 0; i--) {
      const exp = explosions[i]
      exp.age++
      const positions = exp.mesh.geometry.attributes.position.array

      for (let j = 0; j < exp.velocities.length / 3; j++) {
        positions[j * 3] += exp.velocities[j * 3]
        positions[j * 3 + 1] += exp.velocities[j * 3 + 1]
        positions[j * 3 + 2] += exp.velocities[j * 3 + 2]
      }
      exp.mesh.geometry.attributes.position.needsUpdate = true
      exp.mesh.material.opacity = 1 - exp.age / exp.maxAge

      if (exp.age >= exp.maxAge) {
        scene.remove(exp.mesh)
        exp.mesh.geometry.dispose()
        exp.mesh.material.dispose()
        explosions.splice(i, 1)
      }
    }

    updateIndicators()
    renderer.render(scene, camera)
  }

  // === 音效系统 ===
  class SoundManager {
    constructor() {
      this.ctx = null
      this.masterGain = null
      this.bgmGain = null
      this.sfxGain = null
      this.bgmAudio = null
      this.noiseBuffer = null
    }

    init() {
      if (this.ctx) return
      const AudioContext = window.AudioContext || window.webkitAudioContext
      this.ctx = new AudioContext()

      this.masterGain = this.ctx.createGain()
      this.masterGain.gain.value = 1.0
      this.masterGain.connect(this.ctx.destination)

      // BGM 通道
      this.bgmGain = this.ctx.createGain()
      this.bgmGain.gain.value = 0.8
      this.bgmGain.connect(this.masterGain)

      this.bgmAudio = new Audio('bgm.mp3')
      this.bgmAudio.loop = true
      // 使用 MediaElementSource 通过 Web Audio API 路由音频元素
      const bgmSource = this.ctx.createMediaElementSource(this.bgmAudio)
      bgmSource.connect(this.bgmGain)

      // 音效通道
      this.sfxGain = this.ctx.createGain()
      this.sfxGain.gain.value = 0.8
      this.sfxGain.connect(this.masterGain)

      this.noiseBuffer = this.createNoiseBuffer()
    }

    createNoiseBuffer() {
      const bufferSize = this.ctx.sampleRate * 2 // 2 秒
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate)
      const data = buffer.getChannelData(0)
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1
      }
      return buffer
    }

    playBGM() {
      if (this.bgmAudio && this.ctx) {
        if (this.ctx.state === 'suspended') {
          this.ctx.resume()
        }
        this.bgmAudio.play().catch((e) => console.log('BGM play failed (likely autoplay policy):', e))
      }
    }

    setBGMVolume(val) {
      if (this.bgmGain && this.ctx) {
        this.bgmGain.gain.setValueAtTime(val, this.ctx.currentTime)
      }
      // 同时直接在音频元素上设置音量作为备用方案
      if (this.bgmAudio) {
        this.bgmAudio.volume = val
      }
    }

    setSFXVolume(val) {
      if (this.sfxGain) {
        this.sfxGain.gain.setValueAtTime(val, this.ctx.currentTime)
      }
    }

    playTone(freq, type, duration, startTime = 0, vol = 1) {
      if (!this.ctx) return
      const osc = this.ctx.createOscillator()
      const gain = this.ctx.createGain()
      osc.type = type
      osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime)
      gain.gain.setValueAtTime(vol, this.ctx.currentTime + startTime)
      gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration)
      osc.connect(gain)
      gain.connect(this.sfxGain) // 连接到音效增益
      osc.start(this.ctx.currentTime + startTime)
      osc.stop(this.ctx.currentTime + startTime + duration)
    }

    playBoost() {
      if (!this.ctx) return

      const now = this.ctx.currentTime
      const duration = 0.4

      // 主低频冲击音（提供力量感）
      const bassOsc = this.ctx.createOscillator()
      const bassGain = this.ctx.createGain()
      bassOsc.type = 'sawtooth'
      bassOsc.frequency.setValueAtTime(60, now)
      bassOsc.frequency.exponentialRampToValueAtTime(30, now + duration)
      bassGain.gain.setValueAtTime(0.5, now)
      bassGain.gain.exponentialRampToValueAtTime(0.01, now + duration)
      bassOsc.connect(bassGain)
      bassGain.connect(this.sfxGain)

      // 中频增强清晰度
      const midOsc = this.ctx.createOscillator()
      const midGain = this.ctx.createGain()
      midOsc.type = 'square'
      midOsc.frequency.setValueAtTime(300, now)
      midOsc.frequency.exponentialRampToValueAtTime(150, now + 0.15)
      midGain.gain.setValueAtTime(0.2, now)
      midGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2)
      midOsc.connect(midGain)
      midGain.connect(this.sfxGain)

      // 高频冲击音（增强清晰度和攻击性）
      const highOsc = this.ctx.createOscillator()
      const highGain = this.ctx.createGain()
      highOsc.type = 'triangle'
      highOsc.frequency.setValueAtTime(800, now)
      highOsc.frequency.exponentialRampToValueAtTime(400, now + 0.1)
      highGain.gain.setValueAtTime(0.2, now)
      highGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1)
      highOsc.connect(highGain)
      highGain.connect(this.sfxGain)

      // 启动所有振荡器
      bassOsc.start(now)
      bassOsc.stop(now + duration)
      midOsc.start(now)
      midOsc.stop(now + 0.2)
      highOsc.start(now)
      highOsc.stop(now + 0.1)
    }

    playCut() {
      // 爆炸音效
      if (!this.ctx || !this.noiseBuffer) return
      const source = this.ctx.createBufferSource()
      source.buffer = this.noiseBuffer
      const gain = this.ctx.createGain()

      // 低通滤波，模拟爆炸的沉闷感
      const filter = this.ctx.createBiquadFilter()
      filter.type = 'lowpass'
      filter.frequency.setValueAtTime(600, this.ctx.currentTime)
      filter.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 1)

      source.connect(filter)
      filter.connect(gain)
      gain.connect(this.sfxGain)

      gain.gain.setValueAtTime(1.0, this.ctx.currentTime)
      gain.gain.exponentialRampToValueAtTime(0.2, this.ctx.currentTime + 1)

      source.start()
      source.stop(this.ctx.currentTime + 1)
    }

    playDamage() {
      this.playTone(150, 'square', 0.3, 0, 0.5)
      this.playTone(100, 'sawtooth', 0.4, 0, 0.5)
    }

    playGameOver() {
      this.playTone(300, 'triangle', 0.5, 0)
      this.playTone(250, 'triangle', 0.5, 0.4)
      this.playTone(200, 'triangle', 1.0, 0.8)
    }
  }

  const soundManager = new SoundManager()

  init()
</script>
</body>
</html>
