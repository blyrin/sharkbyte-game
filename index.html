<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Shark Byte</title>
  <style>
    *, ::before, ::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #000510;
      font-family: 'Courier New', Courier, monospace;
      color: #00ffcc;
      user-select: none;
    }

    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ° Canvas */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
      box-sizing: border-box;
      text-shadow: 0 0 10px #00ffcc;
    }

    #indicators-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1; /* åœ¨ UI ä¸‹å±‚ï¼Œä½†åœ¨æ¸¸æˆä¸Šå±‚ */
      overflow: hidden;
    }

    .indicator {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 20px solid #ff3333;
      filter: drop-shadow(0 0 5px #ff3333);
      transform-origin: center center;
      display: none; /* é»˜è®¤éšè— */
    }

    .cable-indicator {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 16px solid #00ffcc;
      filter: drop-shadow(0 0 3px #00ffcc);
      transform-origin: center center;
      display: none; /* é»˜è®¤éšè— */
    }

    .hud-top {
      display: flex;
      justify-content: space-between;
      font-size: 16px;
      font-weight: bold;
    }

    .health-bar-container {
      width: 200px;
      height: 12px;
      border: 2px solid #00ff00;
      background: rgba(0, 0, 0, 0.5);
    }

    #health-fill {
      width: 100%;
      height: 100%;
      background-color: #00ff00;
      box-shadow: 0 0 10px #00ff00;
      transition: width 0.2s;
    }

    .stamina-bar-container {
      width: 200px;
      height: 12px;
      border: 2px solid #00ffcc;
      background: rgba(0, 0, 0, 0.5);
    }

    #stamina-fill {
      width: 100%;
      height: 100%;
      background-color: #00ffcc;
      box-shadow: 0 0 10px #00ffcc;
      transition: width 0.2s;
    }

    #score-display {
      color: #ccff00;
      text-shadow: 0 0 10px #ccff00;
    }

    #message-center {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* é»˜è®¤ä¸æ‹¦æˆªäº‹ä»¶ */
      display: flex;
      flex-direction: column;
    }

    h1 {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 48px;
      margin: 0;
      background: linear-gradient(to bottom, #00ffcc, #0055aa);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 10px rgba(0, 255, 204, 0.5));
      pointer-events: none;
    }

    p {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 12px;
      color: #aaa;
      margin: 0;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      border-radius: 5px;
      max-width: 300px;
      text-align: left;
      pointer-events: none;
    }

    button {
      background: transparent;
      border: 2px solid #00ffcc;
      color: #00ffcc;
      padding: 4px 10px;
      font-size: 16px;
      font-family: inherit;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.3s;
      box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
    }

    button:hover {
      background: #00ffcc;
      color: #000;
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
    }

    #damage-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s;
      z-index: 3;
    }

    .key {
      display: inline-block;
      border: 1px solid #fff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      margin: 0 2px;
    }

    .settings-panel {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 20, 40, 0.8);
      padding: 10px;
      border: 1px solid #00ffcc;
      border-radius: 8px;
      text-align: left;
      width: 200px;
      pointer-events: auto; /* å…è®¸äº¤äº’ */
    }

    #start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: auto; /* å…è®¸ç‚¹å‡» */
    }

    .setting-item {
      margin-bottom: 6px;
    }

    .setting-item label {
      display: block;
      margin-bottom: 5px;
      color: #00ffcc;
      font-size: 14px;
    }

    .setting-item input[type='range'] {
      width: 100%;
      accent-color: #00ffcc;
      cursor: pointer;
    }

    /* æš‚åœèœå•æ ·å¼ */
    #pause-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 5, 16, 0.85);
      backdrop-filter: blur(10px);
      z-index: 10;
      display: none; /* é»˜è®¤éšè— */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      pointer-events: auto;
    }

    #pause-menu h2 {
      font-size: 24px;
      color: #00ffcc;
      margin-bottom: 10px;
      text-shadow: 0 0 15px #00ffcc;
      letter-spacing: 5px;
    }

    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
      width: 200px;
    }

    .pause-settings {
      margin-top: 6px;
      background: rgba(0, 20, 40, 0.6);
      padding: 10px;
      border: 1px solid #00ffcc;
      border-radius: 8px;
      width: 200px;
    }

    /* ç§»åŠ¨ç«¯æš‚åœæŒ‰é’® */
    #pause-button-mobile {
      position: fixed;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 8px;
      background: rgba(255, 204, 0, 0.3);
      border: 3px solid #ffcc00;
      color: #ffcc00;
      padding: 4px 12px;
      font-size: 12px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 100;
      box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
      user-select: none;
      touch-action: none;
      transition: all 0.2s;
    }

    #pause-button-mobile:active {
      background: rgba(255, 204, 0, 0.6);
      box-shadow: 0 0 30px rgba(255, 204, 0, 0.8);
      transform: scale(0.95);
    }

    /* ç§»åŠ¨ç«¯å†²åˆºæŒ‰é’® */
    #sprint-button {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(0, 255, 204, 0.3);
      border: 3px solid #00ffcc;
      color: #00ffcc;
      font-size: 14px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 100;
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
      user-select: none;
      touch-action: none;
      transition: all 0.1s;
    }

    #sprint-button.active {
      background: rgba(0, 255, 204, 0.6);
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
      transform: scale(0.95);
    }

    #sprint-button.disabled {
      opacity: 0.4;
      border-color: #666;
      color: #666;
    }

    /* ç§»åŠ¨ç«¯åè§†æŒ‰é’® */
    #back-button {
      position: fixed;
      bottom: 130px;
      left: 160px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 153, 0, 0.3);
      border: 3px solid #ff9900;
      color: #ff9900;
      font-size: 12px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 100;
      box-shadow: 0 0 20px rgba(255, 153, 0, 0.5);
      user-select: none;
      touch-action: none;
      transition: all 0.1s;
    }

    #back-button.active {
      background: rgba(255, 153, 0, 0.6);
      box-shadow: 0 0 30px rgba(255, 153, 0, 0.8);
      transform: scale(0.95);
    }

    /* è™šæ‹Ÿæ‘‡æ†æ ·å¼ */
    #joystick-container {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 120px;
      height: 120px;
      display: none;
      pointer-events: auto;
      z-index: 100;
    }

    #joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(0, 255, 204, 0.2);
      border: 3px solid #00ffcc;
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
    }

    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0, 255, 204, 0.6);
      border: 2px solid #00ffcc;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(0, 255, 204, 0.5);
      transition: all 0.1s;
    }

    #joystick-stick.active {
      background: rgba(0, 255, 204, 0.8);
      box-shadow: 0 0 25px rgba(0, 255, 204, 0.8);
    }

    /* æ¸¸æˆUIéšè—ç±» */
    .hide-game-ui {
      display: none !important;
    }

    /* æ¸¸æˆç»“æŸç•Œé¢æ ·å¼ */
    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      pointer-events: auto;
      background: rgba(0, 5, 16, 0.7);
      backdrop-filter: blur(5px);
    }

    #game-over-screen h1 {
      position: static;
      font-size: 32px;
      margin-bottom: 20px;
    }

    #game-over-screen p {
      position: static;
      font-size: 14px;
      background: transparent;
      color: #00ffcc;
      text-align: center;
    }

    #game-over-screen button {
      pointer-events: auto;
    }

    #final-score {
      color: #ccff00;
      font-weight: bold;
      text-shadow: 0 0 10px #ccff00;
    }

    #high-score-display {
      color: #ff9900;
      text-shadow: 0 0 10px #ff9900;
      font-size: 14px;
      margin-left: 20px;
    }

    .high-score-start {
      position: absolute;
      top: 100px;
      left: 20px;
      color: #ff9900;
      text-shadow: 0 0 10px #ff9900;
      font-size: 18px;
      font-weight: bold;
      pointer-events: none;
    }

    .new-record {
      color: #ff3333;
      font-size: 18px;
      font-weight: bold;
      text-shadow: 0 0 15px #ff3333;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
  <!-- é€šè¿‡ CDN å¼•å…¥ Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<div id="game-container"></div>
<div id="damage-overlay"></div>
<div id="indicators-container" class="hide-game-ui"></div>
<div id="pause-button-mobile" class="hide-game-ui">PAUSE</div>
<div id="sprint-button" class="hide-game-ui">DASH</div>
<div id="back-button" class="hide-game-ui">BACK</div>
<div id="joystick-container" class="hide-game-ui">
  <div id="joystick-base"></div>
  <div id="joystick-stick"></div>
</div>

<div id="ui-layer">
  <div class="hud-top hide-game-ui">
    <div>
      <div id="score-display">æ–­ç½‘è¿›åº¦: 0 TB</div>
      <div id="high-score-display">æœ€é«˜åˆ†: 0 TB</div>
    </div>
    <div style="display: flex; flex-direction: column; gap: 6px;">
      <div class="health-bar-container">
        <div id="health-fill"></div>
      </div>
      <div class="stamina-bar-container">
        <div id="stamina-fill"></div>
      </div>
    </div>
  </div>

  <div id="message-center">
    <h1>Shark Byte</h1>
    <div class="high-score-start">æœ€é«˜åˆ†: <span id="high-score-start-value">0</span> TB</div>
    <button id="start-btn">å¼€å§‹æ½œå…¥</button>
    <div class="settings-panel">
      <div class="setting-item">
        <label for="bgm-slider">BGM</label>
        <input type="range" id="bgm-slider" min="0" max="1" step="0.01" value="0.8" />
      </div>
      <div class="setting-item">
        <label for="sfx-slider">SFX</label>
        <input type="range" id="sfx-slider" min="0" max="1" step="0.01" value="0.8" />
      </div>
    </div>
    <p>
      ä»»åŠ¡ï¼šæ‘§æ¯æµ·åº•å…‰ç¼†ã€‚<br />
      <span id="control-instruction">
        æ§åˆ¶ï¼šé¼ æ ‡ç§»åŠ¨ç„å‡†ï¼Œ<br />
        <span class="key">å·¦é”®</span> å†²åˆº/å’¬ç¢ï¼Œ<span class="key">å³é”®</span> åè§†é•œã€‚<span class="key">P</span>
        æš‚åœã€‚
      </span><br />
      è­¦å‘Šï¼šæ£€æµ‹åˆ°äº‘æœåŠ¡é˜²å¾¡ç³»ç»Ÿ (AWS, Azure, GCP)ã€‚
    </p>
  </div>

  <div id="game-over-screen" style="display: none;">
    <h1>è¿æ¥æ–­å¼€</h1>
    <p id="game-over-message">ä»»åŠ¡å¤±è´¥ã€‚<br>ä½ åˆ‡æ–­äº† <span id="final-score">0</span> TB çš„æ•°æ®ã€‚</p>
    <p id="new-record-message" class="new-record" style="display: none;">ğŸ‰ æ–°çºªå½•ï¼ğŸ‰</p>
    <p style="color: #ff9900; font-size: 16px;">æœ€é«˜åˆ†: <span id="high-score-game-over">0</span> TB</p>
    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
      <button id="restart-btn">é‡æ–°è¿æ¥</button>
      <button id="exit-fullscreen-btn-gameover">é€€å‡ºå…¨å±</button>
    </div>
  </div>
</div>

<div id="pause-menu">
  <h2>PAUSED</h2>
  <div class="pause-buttons">
    <button id="resume-btn">ç»§ç»­æ¸¸æˆ</button>
    <button id="restart-btn-pause">é‡æ–°å¼€å§‹</button>
    <button id="exit-fullscreen-btn">é€€å‡ºå…¨å±</button>
  </div>
  <div class="pause-settings">
    <div class="setting-item">
      <label for="bgm-slider-pause">BGM</label>
      <input type="range" id="bgm-slider-pause" min="0" max="1" step="0.01" value="0.8" />
    </div>
    <div class="setting-item">
      <label for="sfx-slider-pause">SFX</label>
      <input type="range" id="sfx-slider-pause" min="0" max="1" step="0.01" value="0.8" />
    </div>
  </div>
</div>

<script type="module">
  // === ç§»åŠ¨è®¾å¤‡æ£€æµ‹ ===
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)

  // === æ¨ªå±æ£€æµ‹ ===
  function checkOrientation() {
    if (!isMobile) return true
    return window.innerWidth > window.innerHeight
  }

  // === LocalStorage å·¥å…·å‡½æ•° ===
  const Storage = {
    loadHighScore() {
      const saved = localStorage.getItem('sharkByteHighScore')
      return saved ? parseInt(saved, 10) : 0
    },
    saveHighScore(score) {
      localStorage.setItem('sharkByteHighScore', score.toString())
    },
    loadBGMVolume() {
      const saved = localStorage.getItem('sharkByteBgmVolume')
      return saved ? parseFloat(saved) : 0.8
    },
    saveBGMVolume(volume) {
      localStorage.setItem('sharkByteBgmVolume', volume.toString())
    },
    loadSFXVolume() {
      const saved = localStorage.getItem('sharkByteSfxVolume')
      return saved ? parseFloat(saved) : 0.8
    },
    saveSFXVolume(volume) {
      localStorage.setItem('sharkByteSfxVolume', volume.toString())
    },
  }

  // === æ¸¸æˆé…ç½® ===
  const CONFIG = {
    sharkSpeed: 0.4,
    boostSpeed: 1,
    turnSpeed: 0.2, // å¹³æ»‘é€Ÿåº¦
    mouseSensitivity: 0.003, // çµæ•åº¦ (æ¡Œé¢)
    joystickSensitivity: 0.02, // çµæ•åº¦ (ç§»åŠ¨)
    cameraDistance: 15,
    rollFactor: 0.2, // ä¾§å€¾ç³»æ•°
    fogColor: 0x001020,
    maxHealth: 100,
    maxStamina: 100,
    recoverHealth: 5, // å’¬æ–­ç”µç¼†æ¢å¤çš„ç”Ÿå‘½
    staminaDrainRate: 0.4, // æ¯å¸§æ¶ˆè€—
    staminaRecoverRate: 0.2, // æ¯å¸§æ¢å¤
    minStaminaToBoost: 1, // æœ€ä½å†²åˆºéœ€æ±‚
    recoverStamina: 40, // å’¬æ–­ç”µç¼†æ¢å¤çš„è€åŠ›
    enemyRemoveDistance: 150, // æ•Œäººè¶…è¿‡æ­¤è·ç¦»ååˆ é™¤
    maxEnemies: 80, // æœ€å¤§æ•Œäººæ•°
    enemySpeedAWS: 0.45, // AWS æ•Œäººç§»åŠ¨é€Ÿåº¦
    enemySpeedAzure: 0.5, // Azure æ•Œäººç§»åŠ¨é€Ÿåº¦
    enemySpeedGCP: 0.5, // GCP æ•Œäººç§»åŠ¨é€Ÿåº¦
    colors: {
      shark: 0x667788,
      cable: 0x00ffcc, // éœ“è™¹è“
      cableCore: 0xffffff,
      aws: 0xff9900, // æ©™è‰²
      azure: 0x007fff, // è“è‰²
      gcp: 0xea4335, // çº¢è‰²
    },
  }

  // === çŠ¶æ€å˜é‡ ===
  let gameState = {
    isPlaying: false,
    isPaused: false,
    cableCount: 3,
    score: 0,
    highScore: Storage.loadHighScore(), // ä»localStorageåŠ è½½æœ€é«˜åˆ†
    cablesCut: 0, // è®°å½•åˆ‡æ–­ç”µç¼†æ•°é‡
    health: CONFIG.maxHealth,
    stamina: CONFIG.maxStamina,
    time: 0,
  }

  // === Three.js å…¨å±€å˜é‡ ===
  let scene, camera, renderer
  let sharkContainer, sharkMesh, sharkJaw

  // ç”¨äºç´¯ç§¯æ—‹è½¬çš„è§’åº¦å˜é‡
  let sharkEuler = { x: 0, y: 0 }

  let targetRotation = new THREE.Quaternion() // ç”¨äº Slerp çš„ç›®æ ‡å››å…ƒæ•°
  let cables = []
  let enemies = []
  let particles = []
  let explosions = [] // çˆ†ç‚¸ç‰¹æ•ˆæ•°ç»„
  let isBoosting = false
  let isLookingBack = false // è§‚å¯Ÿèº«åçŠ¶æ€
  let clock = new THREE.Clock()

  // ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ†æ§åˆ¶å˜é‡
  let joystickActive = false
  let joystickTouchId = null
  let joystickStartX = 0
  let joystickStartY = 0
  let joystickDeltaX = 0
  let joystickDeltaY = 0
  const joystickMaxDistance = 35 // æ‘‡æ†æœ€å¤§ç§»åŠ¨è·ç¦»

  // å¸§ç‡æ§åˆ¶å˜é‡
  const fpsLimit = 60
  const fpsInterval = 1000 / fpsLimit
  let lastFrameTime = performance.now()

  // æŒ‡ç¤ºå™¨æ›´æ–°é¢‘ç‡æ§åˆ¶
  let indicatorUpdateCounter = 0
  const indicatorUpdateInterval = 2 // æ¯2å¸§æ›´æ–°ä¸€æ¬¡æŒ‡ç¤ºå™¨

  // ç•Œé¢å…ƒç´ 
  const uiScore = document.getElementById('score-display')
  const uiHealth = document.getElementById('health-fill')
  const uiStamina = document.getElementById('stamina-fill')
  const uiMessage = document.getElementById('message-center')
  const bgmSlider = document.getElementById('bgm-slider')
  const sfxSlider = document.getElementById('sfx-slider')
  const damageOverlay = document.getElementById('damage-overlay')
  const indicatorsContainer = document.getElementById('indicators-container')

  // æš‚åœèœå•å…ƒç´ 
  const pauseMenu = document.getElementById('pause-menu')
  const bgmSliderPause = document.getElementById('bgm-slider-pause')
  const sfxSliderPause = document.getElementById('sfx-slider-pause')

  // UIå…ƒç´ é›†åˆ - ç»Ÿä¸€ç®¡ç†
  const gameUIElements = [
    '.hud-top',
    'indicators-container',
    'pause-button-mobile',
    'sprint-button',
    'back-button',
    'joystick-container',
  ]

  // é€šç”¨UIæ˜¾ç¤º/éšè—å‡½æ•°
  function toggleGameUI(show) {
    gameUIElements.forEach(selector => {
      const el = selector.startsWith('.') ? document.querySelector(selector) : document.getElementById(selector)
      if (el) {
        // ç§»åŠ¨ç«¯ä¸“ç”¨æ§ä»¶åªåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæ˜¾ç¤º
        const isMobileControl = ['pause-button-mobile', 'sprint-button', 'back-button', 'joystick-container'].includes(selector)

        if (isMobileControl && !isMobile) {
          el.style.display = 'none'
        } else {
          if (show) {
            el.classList.remove('hide-game-ui')
            // æ¢å¤ç§»åŠ¨ç«¯æ§ä»¶çš„æ˜¾ç¤ºæ–¹å¼
            if (isMobileControl && isMobile) {
              if (selector === 'joystick-container') {
                el.style.display = 'block'
              } else {
                el.style.display = 'flex'
              }
            }
          } else {
            el.classList.add('hide-game-ui')
          }
        }
      }
    })
  }

  // åŒæ­¥éŸ³é‡æ»‘å—
  function syncVolumeSliders(sourceBGM, sourceSFX) {
    bgmSlider.value = sourceBGM
    sfxSlider.value = sourceSFX
    bgmSliderPause.value = sourceBGM
    sfxSliderPause.value = sourceSFX
  }

  // å¤„ç†éŸ³é‡å˜åŒ–
  function handleVolumeChange(type, value) {
    if (type === 'bgm') {
      soundManager.setBGMVolume(value)
      Storage.saveBGMVolume(value)
      bgmSlider.value = value
      bgmSliderPause.value = value
    } else {
      soundManager.setSFXVolume(value)
      Storage.saveSFXVolume(value)
      sfxSlider.value = value
      sfxSliderPause.value = value
    }
  }

  // é€šç”¨å…¨å±è¯·æ±‚
  async function requestFullscreenSafe() {
    try {
      await document.documentElement.requestFullscreen()
    } catch (e) {
      console.log('å…¨å±è¯·æ±‚è¢«æ‹’ç»æˆ–ä¸æ”¯æŒ')
    }
  }

  // é€šç”¨æŒ‰é’®äº‹ä»¶ç»‘å®š
  function addButtonListener(id, callback) {
    const btn = document.getElementById(id)
    if (btn) {
      btn.addEventListener(isMobile ? 'touchstart' : 'click', callback)
    }
  }

  // åˆå§‹åŒ–
  function init() {
    // åœºæ™¯
    scene = new THREE.Scene()
    scene.fog = new THREE.FogExp2(CONFIG.fogColor, 0.01)
    scene.background = new THREE.Color(CONFIG.fogColor)

    // æ‘„åƒæœº
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200)

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      powerPreference: 'high-performance' // è¯·æ±‚é«˜æ€§èƒ½æ¨¡å¼
    })
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2))
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = false
    document.getElementById('game-container').appendChild(renderer.domElement)

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 2) // ç¯å¢ƒå…‰
    scene.add(ambientLight)

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8)
    dirLight.position.set(10, 50, 20)
    dirLight.castShadow = false
    scene.add(dirLight)

    // èšå…‰ç¯ï¼ˆæ¨¡æ‹Ÿé²¨é±¼å¤´ç¯/æµ·åº•å…‰çº¿ï¼‰
    const spotLight = new THREE.SpotLight(0x00ffff, 1)
    spotLight.position.set(0, 10, 0)
    spotLight.angle = Math.PI / 4
    spotLight.penumbra = 0.1
    scene.add(spotLight)

    // åˆ›å»ºæ¸¸æˆå¯¹è±¡
    createEnvironment()
    createShark()
    generateCables()

    // äº‹ä»¶ç›‘å¬
    window.addEventListener('resize', onWindowResize, false)

    if (isMobile) {
      // ç§»åŠ¨ç«¯ï¼šä½¿ç”¨è™šæ‹Ÿæ‘‡æ†æ§åˆ¶
      const joystickContainer = document.getElementById('joystick-container')
      joystickContainer.addEventListener('touchstart', onJoystickStart, { passive: false })
      joystickContainer.addEventListener('touchmove', onJoystickMove, { passive: false })
      joystickContainer.addEventListener('touchend', onJoystickEnd, { passive: false })

      // å†²åˆºæŒ‰é’®äº‹ä»¶
      const sprintBtn = document.getElementById('sprint-button')
      sprintBtn.addEventListener('touchstart', onSprintButtonDown, { passive: false })
      sprintBtn.addEventListener('touchend', onSprintButtonUp, { passive: false })

      // æš‚åœæŒ‰é’®äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
      const pauseBtn = document.getElementById('pause-button-mobile')
      pauseBtn.addEventListener('touchstart', (e) => {
        e.preventDefault()
        e.stopPropagation()
        togglePause(true)
      }, { passive: false })

      // BACKæŒ‰é’®äº‹ä»¶
      const backBtn = document.getElementById('back-button')
      backBtn.addEventListener('touchstart', onBackButtonDown, { passive: false })
      backBtn.addEventListener('touchend', onBackButtonUp, { passive: false })

      // æ›´æ–°UIæç¤º
      document.getElementById('control-instruction').innerHTML = 'æ§åˆ¶ï¼šå·¦ä¸‹è§’æ‘‡æ†ç§»åŠ¨è§†è§’ï¼Œ<br />å³ä¸‹è§’DASHæŒ‰é’®å†²åˆº/å’¬ç¢ï¼ŒBACKæŒ‰é’®æŸ¥çœ‹èº«åã€‚'
    } else {
      // æ¡Œé¢ç«¯ï¼šä½¿ç”¨é¼ æ ‡
      document.addEventListener('mousemove', onMouseMoveInfinite, false)
      document.addEventListener('mousedown', onMouseDown, false)
      document.addEventListener('mouseup', onMouseUp, false)
      // ç›‘å¬æŒ‡é’ˆé”å®šçŠ¶æ€å˜åŒ–
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== document.body && gameState.isPlaying) {
          togglePause(true)
        }
      })
    }

    document.addEventListener('contextmenu', (e) => e.preventDefault(), false)

    // ç›‘å¬å±å¹•å¤§å°å˜åŒ–ï¼ˆæ–¹å‘å˜åŒ–ï¼‰
    window.addEventListener('resize', () => {
      if (isMobile && gameState.isPlaying && !gameState.isPaused) {
        if (!checkOrientation()) {
          togglePause(true)
          window.confirm('è¯·å°†è®¾å¤‡æ—‹è½¬è‡³æ¨ªå±æ¨¡å¼ä»¥ç»§ç»­æ¸¸æˆ')
        }
      }
    })

    addButtonListener('start-btn', () => {
      setTimeout(startGame, 100)
    })
    addButtonListener('restart-btn', startGame)
    addButtonListener('exit-fullscreen-btn-gameover', () => {
      if (document.fullscreenElement) document.exitFullscreen()
    })

    bgmSlider.addEventListener('input', (e) => handleVolumeChange('bgm', parseFloat(e.target.value)))
    sfxSlider.addEventListener('input', (e) => handleVolumeChange('sfx', parseFloat(e.target.value)))
    bgmSliderPause.addEventListener('input', (e) => handleVolumeChange('bgm', parseFloat(e.target.value)))
    sfxSliderPause.addEventListener('input', (e) => handleVolumeChange('sfx', parseFloat(e.target.value)))

    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyP') togglePause(true)
    })

    addButtonListener('resume-btn', async () => {
      if (isMobile && !checkOrientation()) {
        window.confirm('è¯·å°†è®¾å¤‡æ—‹è½¬è‡³æ¨ªå±æ¨¡å¼åå†ç»§ç»­æ¸¸æˆ')
        return
      }
      await requestFullscreenSafe()
      togglePause(false)
    })

    addButtonListener('restart-btn-pause', () => {
      togglePause(false)
      setTimeout(startGame, 100)
    })

    addButtonListener('exit-fullscreen-btn', () => {
      if (document.fullscreenElement) document.exitFullscreen()
    })

    // æå‰åˆå§‹åŒ–éŸ³æ•ˆç®¡ç†å™¨ä»¥å¯ç”¨éŸ³é‡æ§åˆ¶
    soundManager.init()

    // ä»localStorageåŠ è½½éŸ³é‡è®¾ç½®
    const savedBGMVolume = Storage.loadBGMVolume()
    const savedSFXVolume = Storage.loadSFXVolume()
    syncVolumeSliders(savedBGMVolume, savedSFXVolume)
    soundManager.setBGMVolume(savedBGMVolume)
    soundManager.setSFXVolume(savedSFXVolume)

    // åˆå§‹åŒ–æœ€é«˜åˆ†æ˜¾ç¤º
    updateHUD()

    // å¼€å§‹å¾ªç¯
    animate()
  }

  // === æ ¸å¿ƒé€»è¾‘ï¼šåˆ›å»ºé²¨é±¼ï¼ˆä½å¤šè¾¹å½¢é£æ ¼ï¼‰===
  function createShark() {
    sharkContainer = new THREE.Group()
    scene.add(sharkContainer)

    // èº«ä½“
    const bodyGeo = new THREE.ConeGeometry(1, 4, 6)
    bodyGeo.rotateX(Math.PI / 2) // è®©åœ†é”¥èººä¸‹ï¼ŒæŒ‡å‘ Z è½´ï¼ˆThree.js é»˜è®¤æœå‘ï¼‰
    const bodyMat = new THREE.MeshPhongMaterial({ color: CONFIG.colors.shark, flatShading: true })
    sharkMesh = new THREE.Mesh(bodyGeo, bodyMat)
    sharkMesh.castShadow = false
    sharkContainer.add(sharkMesh)

    // å°¾å·´
    const tailGeo = new THREE.BoxGeometry(0.1, 1.3, 1.2)
    tailGeo.translate(0, 0, 2.2)
    const tail = new THREE.Mesh(tailGeo, bodyMat)
    sharkMesh.add(tail)

    // é³
    const finGeo = new THREE.BufferGeometry()
    const finVertices = new Float32Array([0, 0.5, -0.5, 0, 0.5, 0.5, 0, 2.0, 0.5])
    finGeo.setAttribute('position', new THREE.BufferAttribute(finVertices, 3))
    finGeo.computeVertexNormals()
    const fin = new THREE.Mesh(finGeo, bodyMat)
    fin.material.side = THREE.DoubleSide
    sharkMesh.add(fin)

    // çœ¼
    const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8)
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 })
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat)
    eyeL.position.set(0.5, 0.3, -3)
    sharkMesh.add(eyeL)
    const eyeR = eyeL.clone()
    eyeR.position.set(-0.5, 0.3, -3)
    sharkMesh.add(eyeR)

    // å˜´
    const jawGeo = new THREE.ConeGeometry(0.8, 2, 8)
    jawGeo.rotateX(-Math.PI / 2)
    sharkJaw = new THREE.Mesh(jawGeo, new THREE.MeshPhongMaterial({ color: 0x333333, flatShading: true }))
    sharkJaw.position.set(0, 0, -3.4)
    sharkJaw.scale.set(1.4, 1.2, 1.4)
    sharkMesh.add(sharkJaw)
  }

  // === æ ¸å¿ƒé€»è¾‘ï¼šåˆ›å»ºæµ·åº•å…‰ç¼† ===
  function generateCables() {
    cables.forEach((c) => {
      scene.remove(c.mesh)
      // æ¸…ç†æŒ‡ç¤ºå™¨å…ƒç´ 
      if (c.indicatorEl) {
        c.indicatorEl.remove()
      }
    })
    cables = []

    // ç¡®å®šç”µç¼†çš„ç”Ÿæˆå‚è€ƒç‚¹ã€‚å¦‚æœæ­£åœ¨æ¸¸æˆï¼Œåˆ™ä½¿ç”¨é²¨é±¼çš„å½“å‰ä½ç½®ï¼Œå¦åˆ™ä½¿ç”¨åŸç‚¹ã€‚
    const refPosition = gameState.isPlaying ? sharkContainer.position.clone() : new THREE.Vector3(0, 0, 0)

    for (let i = 0; i < gameState.cableCount; i++) {
      // ä¼ å…¥å‚è€ƒä½ç½®ï¼Œä½¿æ–°ç”µç¼†ç”Ÿæˆåœ¨é²¨é±¼å‰æ–¹
      spawnCable(refPosition)
    }
    // ç”µç¼†æ•°é‡å¢åŠ 
    gameState.cableCount += 1
  }

  function spawnCable(refPosition) {
    const pathPoints = []

    // ç¡®ä¿æ–°ç”µç¼†åˆ·æ–°åœ¨é²¨é±¼å‰æ–¹ï¼Œå¹¶ä¸”ä½ç½®æ˜¯éšæœºæ•£å¸ƒçš„
    const spawnDistance = 150 // æ–°ç”µç¼†è·ç¦»é²¨é±¼çš„å¤§è‡´è·ç¦»
    // è·å–é²¨é±¼çš„å‰è¿›æ–¹å‘ï¼ˆZ è½´è´Ÿæ–¹å‘ï¼Œä»¥ä¸–ç•Œåæ ‡ç³»è¡¨ç¤ºï¼‰
    const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(sharkContainer.quaternion)

    // 1. è®¡ç®—åŸºæœ¬ç”Ÿæˆç‚¹ï¼ˆé²¨é±¼ä½ç½® + å‰æ–¹è·ç¦»ï¼‰
    let basePos = refPosition.clone().add(forwardVector.clone().multiplyScalar(spawnDistance))

    // 2. è®¡ç®—ä¾§å‘å’Œå‚ç›´çš„éšæœºåç§»ï¼ˆç¡®ä¿æ•£å¸ƒåœ¨é²¨é±¼çš„è§†é‡å‘¨å›´ï¼‰
    const upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(sharkContainer.quaternion)
    const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(sharkContainer.quaternion)

    // ä¾§å‘ +/- 50
    basePos.add(rightVector.clone().multiplyScalar((Math.random() - 0.5) * 100))
    // å‚ç›´ +/- 30
    basePos.add(upVector.clone().multiplyScalar((Math.random() - 0.5) * 60))

    // 3. å¢åŠ æ²¿å‰è¿›æ–¹å‘çš„éšæœºæŠ–åŠ¨
    basePos.add(forwardVector.clone().multiplyScalar((Math.random() - 0.5) * 50))

    let currentPos = basePos.clone()

    for (let j = 0; j < 20; j++) {
      pathPoints.push(currentPos.clone())
      // è®©ç”µç¼†çš„è·¯å¾„ä¿æŒéšæœºèœ¿èœ’çš„ç‰¹æ€§
      currentPos.x += (Math.random() - 0.5) * 30
      currentPos.y += (Math.random() - 0.5) * 10
      currentPos.z -= Math.random() * 40 + 20
    }

    const curve = new THREE.CatmullRomCurve3(pathPoints)
    const geometry = new THREE.TubeGeometry(curve, 32, 0.3, 6, false)
    const material = new THREE.MeshStandardMaterial({
      color: 0x222222,
      emissive: CONFIG.colors.cable,
      emissiveIntensity: 2,
      roughness: 0.4,
      metalness: 0.8,
    })

    const mesh = new THREE.Mesh(geometry, material)
    scene.add(mesh)

    const points = curve.getPoints(30)

    // åˆ›å»ºå…‰ç¼†æŒ‡ç¤ºå™¨å…ƒç´ 
    const indicatorEl = document.createElement('div')
    indicatorEl.className = 'cable-indicator'
    indicatorsContainer.appendChild(indicatorEl)

    cables.push({
      mesh: mesh,
      curve: curve,
      points: points,
      active: true,
      indicatorEl: indicatorEl,
    })
  }

  // === ç¯å¢ƒç²’å­ ===
  function createEnvironment() {
    const partGeo = new THREE.BufferGeometry()
    const partCount = 250
    const posArray = new Float32Array(partCount * 3)
    for (let i = 0; i < partCount * 3; i++) {
      posArray[i] = (Math.random() - 0.5) * 200
    }
    partGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3))
    const partMat = new THREE.PointsMaterial({
      size: 0.5,
      color: 0x88aaff,
      transparent: true,
      opacity: 0.6,
    })
    const particleSystem = new THREE.Points(partGeo, partMat)
    scene.add(particleSystem)
    particles.push(particleSystem)
  }

  // === çˆ†ç‚¸ç‰¹æ•ˆ ===
  function createExplosion(position) {
    const particleCount = 50
    const geometry = new THREE.BufferGeometry()
    const positions = []
    const velocities = []

    for (let i = 0; i < particleCount; i++) {
      positions.push(position.x, position.y, position.z)
      // éšæœºå‘å››å‘¨æ‰©æ•£çš„é€Ÿåº¦
      velocities.push((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3)
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3))

    const material = new THREE.PointsMaterial({
      color: 0xff5500, // çˆ†ç‚¸æ©™çº¢è‰²
      size: 0.6, // ç¨å¾®å¢å¤§ç²’å­å¤§å°ä»¥è¡¥å¿æ•°é‡å‡å°‘
      transparent: true,
      opacity: 1,
      blending: THREE.AdditiveBlending,
    })

    const explosionMesh = new THREE.Points(geometry, material)
    scene.add(explosionMesh)

    explosions.push({
      mesh: explosionMesh,
      velocities: velocities,
      age: 0,
      maxAge: 120,
    })
  }

  function createLabel(text) {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')

    const fontSize = 40
    // å…ˆç”¨é€»è¾‘åƒç´ æµ‹é‡æ–‡æœ¬å®½åº¦
    ctx.font = `bold ${fontSize}px "Courier New"`
    const textMetrics = ctx.measureText(text)
    const logicalWidth = Math.ceil(textMetrics.width + 20)
    const logicalHeight = Math.ceil(fontSize + 20)

    // æŒ‰ DPR æ”¾å¤§å®é™…åƒç´ å°ºå¯¸ï¼Œä¿æŒæ¸…æ™°
    const dpr = Math.min(window.devicePixelRatio || 1, 2)
    canvas.width = Math.max(1, Math.floor(logicalWidth * dpr))
    canvas.height = Math.max(1, Math.floor(logicalHeight * dpr))

    // å°†ç»˜å›¾åæ ‡ç³»ç¼©æ”¾å›é€»è¾‘åƒç´ ï¼Œé¿å…è§†è§‰å°ºå¯¸å˜åŒ–
    ctx.scale(dpr, dpr)

    // é‡æ–°è®¾ç½®ç»˜åˆ¶æ ·å¼
    ctx.font = `bold ${fontSize}px "Courier New"`
    ctx.fillStyle = '#ff3333'
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'
    ctx.shadowColor = '#ff3333'
    ctx.shadowBlur = 5
    ctx.fillText(text, logicalWidth / 2, logicalHeight / 2)

    const texture = new THREE.CanvasTexture(canvas)
    // æ–‡å­—çº¹ç†ä½¿ç”¨çº¿æ€§è¿‡æ»¤å¹¶ç¦ç”¨ mipmap ä»¥å‡å°‘æ¨¡ç³Š
    texture.minFilter = THREE.LinearFilter
    texture.magFilter = THREE.LinearFilter
    texture.generateMipmaps = false
    texture.needsUpdate = true

    const material = new THREE.SpriteMaterial({ map: texture, transparent: true })
    const sprite = new THREE.Sprite(material)
    // ä½¿ç”¨é€»è¾‘åƒç´ æ§åˆ¶ä¸–ç•Œå°ºå¯¸ï¼ˆä¸å— DPR æ”¾å¤§å½±å“ï¼‰
    sprite.scale.set(logicalWidth / 60, logicalHeight / 60, 1)
    return sprite
  }

  // === æ•Œäººç”Ÿæˆé€»è¾‘ ===
  function spawnEnemy() {
    if (!gameState.isPlaying) return
    if (enemies.length >= CONFIG.maxEnemies) return

    const typeRand = Math.random()
    let type = 'aws'
    if (typeRand > 0.7) type = 'azure'
    if (typeRand > 0.9) type = 'gcp'

    const sharkDir = new THREE.Vector3()
    sharkContainer.getWorldDirection(sharkDir)
    sharkDir.normalize()

    const spawnDist = 60 + Math.random() * 20
    const spawnBase = sharkContainer.position.clone().add(sharkDir.multiplyScalar(spawnDist))

    const offset = new THREE.Vector3(
      (Math.random() - 0.5) * 60,
      (Math.random() - 0.5) * 40,
      (Math.random() - 0.5) * 20,
    )
    const spawnPos = spawnBase.add(offset)

    let geo, mat, speed, damage, labelText

    if (type === 'aws') {
      geo = new THREE.BoxGeometry(2, 2, 2)
      mat = new THREE.MeshPhongMaterial({ 
        color: CONFIG.colors.aws, 
        emissive: 0xff6600, 
        emissiveIntensity: 0.5,
        flatShading: true // ä½¿ç”¨å¹³é¢ç€è‰²å‡å°‘è®¡ç®—
      })
      speed = CONFIG.enemySpeedAWS
      damage = 10
      labelText = 'AWS Enforcer'
    } else if (type === 'azure') {
      geo = new THREE.TetrahedronGeometry(1.5)
      mat = new THREE.MeshPhongMaterial({ 
        color: CONFIG.colors.azure, 
        emissive: 0x0000ff, 
        emissiveIntensity: 0.5,
        flatShading: true // ä½¿ç”¨å¹³é¢ç€è‰²å‡å°‘è®¡ç®—
      })
      speed = CONFIG.enemySpeedAzure
      damage = 5
      labelText = 'Azure Sentinel'
    } else {
      geo = new THREE.IcosahedronGeometry(1.2, 0) // é™ä½ç»†åˆ†çº§åˆ«ä»1åˆ°0
      mat = new THREE.MeshPhongMaterial({ 
        color: CONFIG.colors.gcp, 
        wireframe: true, 
        emissive: 0xffffff,
        flatShading: true // ä½¿ç”¨å¹³é¢ç€è‰²å‡å°‘è®¡ç®—
      })
      speed = CONFIG.enemySpeedGCP
      damage = 20
      labelText = 'GCP Guardian'
    }

    const group = new THREE.Group()
    group.position.copy(spawnPos)

    const mesh = new THREE.Mesh(geo, mat)
    group.add(mesh)

    const label = createLabel(labelText)
    label.position.set(0, 2.5, 0) // å°†æ ‡ç­¾æ”¾ç½®åœ¨æ— äººæœºä¸Šæ–¹
    group.add(label)

    scene.add(group)

    const indicatorEl = document.createElement('div')
    indicatorEl.className = 'indicator'
    indicatorsContainer.appendChild(indicatorEl)

    enemies.push({
      group: group, // å­˜å‚¨ç»„è€Œä¸æ˜¯ç½‘æ ¼
      mesh: mesh, // ä¿ç•™å¯¹ç½‘æ ¼çš„å¼•ç”¨ç”¨äºæ—‹è½¬
      type: type,
      speed: speed,
      damage: damage,
      life: 100,
      indicatorEl: indicatorEl,
    })
  }

  // === è™šæ‹Ÿæ‘‡æ†è¾“å…¥å¤„ç† ===
  function getTouchById(touchList, id) {
    for (let i = 0; i < touchList.length; i++) {
      if (touchList[i].identifier === id) return touchList[i]
    }
    return null
  }

  function onJoystickStart(event) {
    if (!gameState.isPlaying || gameState.isPaused) return

    event.preventDefault()
    event.stopPropagation()

    const touch = (event.changedTouches && event.changedTouches[0]) ? event.changedTouches[0] : event.touches[0]
    const rect = event.currentTarget.getBoundingClientRect()
    joystickTouchId = touch.identifier

    // å°†è§¦æ‘¸èµ·å§‹ç‚¹è®¾ç½®ä¸ºå®¹å™¨çš„ä¸­å¿ƒç‚¹,è€Œä¸æ˜¯è§¦æ‘¸ä½ç½®
    joystickStartX = rect.left + rect.width / 2
    joystickStartY = rect.top + rect.height / 2
    joystickActive = true

    const joystickStick = document.getElementById('joystick-stick')
    joystickStick.classList.add('active')

    // ç«‹å³æ›´æ–°æ‘‡æ†ä½ç½®,ç¡®ä¿ä»æ­£ç¡®çš„èµ·å§‹ä½ç½®å¼€å§‹
    updateJoystickPosition(touch.clientX, touch.clientY)
  }

  function onJoystickMove(event) {
    if (!gameState.isPlaying || gameState.isPaused || !joystickActive) return

    event.preventDefault()
    event.stopPropagation()

    let touch = getTouchById(event.touches, joystickTouchId)
    if (!touch && event.changedTouches) {
      touch = getTouchById(event.changedTouches, joystickTouchId)
    }
    if (!touch) return

    updateJoystickPosition(touch.clientX, touch.clientY)
  }

  function onJoystickEnd(event) {
    event.preventDefault()
    event.stopPropagation()

    // ä»…åœ¨å½“å‰è·Ÿè¸ªçš„è§¦ç‚¹ç»“æŸæ—¶æ‰é‡ç½®æ‘‡æ†
    let ended = false
    if (event.changedTouches) {
      for (let i = 0; i < event.changedTouches.length; i++) {
        if (event.changedTouches[i].identifier === joystickTouchId) {
          ended = true
          break
        }
      }
    }
    if (!ended) return

    joystickActive = false
    joystickTouchId = null
    joystickDeltaX = 0
    joystickDeltaY = 0

    // é‡ç½®æ‘‡æ†èµ·å§‹ä½ç½®,ç¡®ä¿ä¸‹æ¬¡è§¦æ‘¸æ—¶ä»æ­£ç¡®ä½ç½®å¼€å§‹
    joystickStartX = 0
    joystickStartY = 0

    const joystickStick = document.getElementById('joystick-stick')
    joystickStick.classList.remove('active')
    joystickStick.style.transform = 'translate(-50%, -50%)'
  }

  function updateJoystickPosition(touchX, touchY) {
    let deltaX = touchX - joystickStartX
    let deltaY = touchY - joystickStartY

    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)
    const normalizedDistance = Math.min(distance / joystickMaxDistance, 1.0) // å½’ä¸€åŒ–è·ç¦» 0-1

    if (distance > joystickMaxDistance) {
      const angle = Math.atan2(deltaY, deltaX)
      deltaX = Math.cos(angle) * joystickMaxDistance
      deltaY = Math.sin(angle) * joystickMaxDistance
    }

    // ä¿å­˜å½’ä¸€åŒ–çš„æ–¹å‘å’Œè·ç¦»ï¼Œç”¨äºé€Ÿåº¦æ§åˆ¶
    const direction = distance > 0 ? 1 : 0
    joystickDeltaX = (deltaX / joystickMaxDistance) * normalizedDistance * direction
    joystickDeltaY = (deltaY / joystickMaxDistance) * normalizedDistance * direction

    const joystickStick = document.getElementById('joystick-stick')
    joystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`
  }

  // === å†²åˆºæŒ‰é’®äº‹ä»¶å¤„ç† ===
  function onSprintButtonDown(event) {
    if (!gameState.isPlaying || gameState.isPaused) return

    event.preventDefault()
    event.stopPropagation()

    const sprintBtn = document.getElementById('sprint-button')

    if (gameState.stamina >= CONFIG.minStaminaToBoost) {
      isBoosting = true
      sprintBtn.classList.add('active')
      soundManager.playBoost()
    }
  }

  function onSprintButtonUp(event) {
    event.preventDefault()
    event.stopPropagation()

    const sprintBtn = document.getElementById('sprint-button')
    isBoosting = false
    sprintBtn.classList.remove('active')
  }

  // === BACKæŒ‰é’®äº‹ä»¶å¤„ç† ===
  function onBackButtonDown(event) {
    if (!gameState.isPlaying || gameState.isPaused) return

    event.preventDefault()
    event.stopPropagation()

    const backBtn = document.getElementById('back-button')
    isLookingBack = true
    backBtn.classList.add('active')
  }

  function onBackButtonUp(event) {
    event.preventDefault()
    event.stopPropagation()

    const backBtn = document.getElementById('back-button')
    isLookingBack = false
    backBtn.classList.remove('active')
  }

  // === è¾“å…¥å¤„ç†ï¼ˆé¼ æ ‡æ§åˆ¶ï¼‰===
  function onMouseMoveInfinite(event) {
    if (isLookingBack) return
    if (document.pointerLockElement === document.body && gameState.isPlaying) {
      // ç´¯ç§¯åèˆªè§’ï¼ˆYè½´æ—‹è½¬ï¼‰
      sharkEuler.y -= event.movementX * CONFIG.mouseSensitivity

      // ç´¯ç§¯ä¿¯ä»°è§’ï¼ˆXè½´æ—‹è½¬ï¼‰- é¼ æ ‡ä¸Šç§» = æŠ¬å¤´ï¼ˆéåè½¬æ§åˆ¶ï¼‰
      sharkEuler.x -= event.movementY * CONFIG.mouseSensitivity

      // é™åˆ¶ä¸Šä¸‹ä¿¯ä»°è§’åº¦ï¼Œé˜²æ­¢ç¿»ä¸ªåº•æœå¤©ï¼ˆé™åˆ¶åœ¨ -80åº¦ åˆ° 80åº¦ï¼‰
      sharkEuler.x = Math.max(-1.4, Math.min(1.4, sharkEuler.x))
    }
  }

  function onMouseDown(event) {
    if (!gameState.isPlaying) return
    if (gameState.isPaused) return

    if (event.button === 2) {
      isLookingBack = true
      return
    }

    // åªåœ¨æ¡Œé¢ç«¯ä½¿ç”¨æŒ‡é’ˆé”å®š
    if (!isMobile && document.pointerLockElement !== document.body) {
      document.body.requestPointerLock()
    }

    // åªæœ‰åœ¨è€åŠ›è¶³å¤Ÿæ—¶æ‰èƒ½å†²åˆº
    if (gameState.stamina >= CONFIG.minStaminaToBoost) {
      isBoosting = true
      soundManager.playBoost()
    }
  }

  function onMouseUp(event) {
    if (event.button === 2) {
      isLookingBack = false
      return
    }
    isBoosting = false
  }

  function togglePause(pause) {
    if (!gameState.isPlaying) return

    gameState.isPaused = pause

    if (gameState.isPaused) {
      pauseMenu.style.display = 'flex'
      if (!isMobile) document.exitPointerLock()
      syncVolumeSliders(bgmSlider.value, sfxSlider.value)
      toggleGameUI(false)
    } else {
      pauseMenu.style.display = 'none'
      if (!isMobile) document.body.requestPointerLock()
      toggleGameUI(true)
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2))
    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  // === æ¸¸æˆé€»è¾‘ ===
  async function startGame() {
    // ç§»åŠ¨ç«¯å¤„ç†
    if (isMobile) {
      await requestFullscreenSafe()
      if (!checkOrientation()) {
        window.confirm('ä¸ºäº†è·å¾—æœ€ä½³æ¸¸æˆä½“éªŒï¼Œè¯·å°†è®¾å¤‡æ—‹è½¬è‡³æ¨ªå±æ¨¡å¼')
        return
      }
    } else {
      // æ¡Œé¢ç«¯å¤„ç†
      await requestFullscreenSafe()
      document.body.requestPointerLock().catch((err) => {console.error(err)})
    }

    console.log('åˆå§‹åŒ–éŸ³æ•ˆå’Œæ¸¸æˆçŠ¶æ€...')
    soundManager.playBGM()

    // é‡ç½®æ‰€æœ‰ gameState çŠ¶æ€
    gameState.isPlaying = true
    gameState.isPaused = false
    gameState.score = 0
    gameState.cablesCut = 0
    gameState.cableCount = 3 // é‡ç½®ç”µç¼†æ•°é‡
    gameState.health = CONFIG.maxHealth
    gameState.stamina = CONFIG.maxStamina
    gameState.time = 0

    // é‡ç½®å…¨å±€æ§åˆ¶å˜é‡
    isBoosting = false
    isLookingBack = false

    // é‡ç½®è™šæ‹Ÿæ‘‡æ†çŠ¶æ€
    joystickActive = false
    joystickTouchId = null
    joystickStartX = 0
    joystickStartY = 0
    joystickDeltaX = 0
    joystickDeltaY = 0

    // é‡ç½®è™šæ‹Ÿæ‘‡æ†UI
    const joystickStick = document.getElementById('joystick-stick')
    if (joystickStick) {
      joystickStick.classList.remove('active')
      joystickStick.style.transform = 'translate(-50%, -50%)'
    }

    // é‡ç½®ç§»åŠ¨ç«¯æŒ‰é’®çŠ¶æ€
    const sprintBtn = document.getElementById('sprint-button')
    if (sprintBtn) {
      sprintBtn.classList.remove('active', 'disabled')
    }
    const backBtn = document.getElementById('back-button')
    if (backBtn) {
      backBtn.classList.remove('active')
    }

    // éšè—UIç•Œé¢
    uiMessage.style.display = 'none'
    document.getElementById('game-over-screen').style.display = 'none'

    // é‡ç½®é²¨é±¼ä½ç½®å’Œæ—‹è½¬
    sharkContainer.position.set(0, 0, 0)
    sharkContainer.quaternion.identity()
    sharkEuler = { x: 0, y: 0 }
    targetRotation.identity()

    // æ¸…ç†æ•Œäºº
    enemies.forEach((e) => {
      scene.remove(e.group)
      if (e.indicatorEl) e.indicatorEl.remove()
    })
    enemies = []

    // æ¸…ç†ç”µç¼†
    cables.forEach((c) => {
      scene.remove(c.mesh)
      if (c.indicatorEl) c.indicatorEl.remove()
    })
    cables = []

    // æ¸…ç†çˆ†ç‚¸ç‰¹æ•ˆ
    explosions.forEach((exp) => {
      scene.remove(exp.mesh)
      exp.mesh.geometry.dispose()
      exp.mesh.material.dispose()
    })
    explosions = []

    // é‡ç½®æ—¶é’Ÿ
    clock = new THREE.Clock()

    // ç”Ÿæˆæ–°ç”µç¼†
    generateCables()

    // æ˜¾ç¤ºæ¸¸æˆUIå¹¶æ›´æ–°HUD
    toggleGameUI(true)
    updateHUD()
  }

  function gameOver() {
    soundManager.playGameOver()
    gameState.isPlaying = false
    document.exitPointerLock()

    // æ£€æŸ¥å¹¶æ›´æ–°æœ€é«˜åˆ†
    let isNewRecord = false
    if (gameState.score > gameState.highScore) {
      gameState.highScore = gameState.score
      Storage.saveHighScore(gameState.highScore)
      isNewRecord = true
    }

    // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
    document.getElementById('game-over-screen').style.display = 'flex'
    document.getElementById('final-score').innerText = String(gameState.score)
    document.getElementById('high-score-game-over').innerText = String(gameState.highScore)

    // æ˜¾ç¤º/éšè—æ–°çºªå½•æç¤º
    document.getElementById('new-record-message').style.display = isNewRecord ? 'block' : 'none'

    // éšè—å¼€å§‹ç•Œé¢
    uiMessage.style.display = 'none'

    toggleGameUI(false)
  }

  function takeDamage(amount) {
    gameState.health -= amount
    damageOverlay.style.opacity = '0.8'
    setTimeout(() => {
      damageOverlay.style.opacity = '0'
    }, 500)

    if (gameState.health <= 0) {
      gameState.health = 0
      gameOver()
    }
    updateHUD()
  }

  function updateHUD() {
    uiScore.innerText = `æ–­ç½‘è¿›åº¦: ${gameState.score} TB`
    uiHealth.style.width = `${gameState.health}%`
    uiStamina.style.width = `${gameState.stamina}%`

    // æ›´æ–°æœ€é«˜åˆ†æ˜¾ç¤º
    const highScoreDisplay = document.getElementById('high-score-display')
    if (highScoreDisplay) {
      highScoreDisplay.innerText = `æœ€é«˜åˆ†: ${gameState.highScore} TB`
    }
    const highScoreStartValue = document.getElementById('high-score-start-value')
    if (highScoreStartValue) {
      highScoreStartValue.innerText = String(gameState.highScore)
    }
  }

  // è®¡ç®—æŒ‡ç¤ºå™¨å±å¹•ä½ç½®çš„è¾…åŠ©å‡½æ•°
  function calculateIndicatorPosition(pos, screenThreshold, widthHalf, heightHalf) {
    const isBehind = pos.z > 1
    const isOnScreen = pos.x > -screenThreshold && pos.x < screenThreshold &&
      pos.y > -screenThreshold && pos.y < screenThreshold && !isBehind

    if (isOnScreen) return null

    let tx = pos.x
    let ty = pos.y

    if (isBehind) {
      tx = -tx
      ty = -ty
    }

    const angle = Math.atan2(ty, tx)
    const absX = Math.abs(tx)
    const absY = Math.abs(ty)

    if (absX > absY) {
      const scale = screenThreshold / absX
      tx = (tx > 0 ? 1 : -1) * screenThreshold
      ty = ty * scale
    } else {
      const scale = screenThreshold / absY
      ty = (ty > 0 ? 1 : -1) * screenThreshold
      tx = tx * scale
    }

    const screenX = tx * widthHalf + widthHalf
    const screenY = -(ty * heightHalf) + heightHalf
    const deg = (angle * 180) / Math.PI - 90

    return { screenX, screenY, deg }
  }

  function updateIndicators() {
    const width = window.innerWidth
    const height = window.innerHeight
    const widthHalf = width / 2
    const heightHalf = height / 2

    // æ›´æ–°æ•ŒäººæŒ‡ç¤ºå™¨
    enemies.forEach((enemy) => {
      if (!enemy.indicatorEl) return

      const pos = enemy.group.position.clone()
      pos.project(camera)

      const result = calculateIndicatorPosition(pos, 0.9, widthHalf, heightHalf)

      if (!result) {
        enemy.indicatorEl.style.display = 'none'
      } else {
        enemy.indicatorEl.style.display = 'block'
        enemy.indicatorEl.style.left = `${result.screenX}px`
        enemy.indicatorEl.style.top = `${result.screenY}px`
        enemy.indicatorEl.style.transform = `translate(-50%, -50%) rotate(${-result.deg}deg)`
      }
    })

    // æ›´æ–°å…‰ç¼†æŒ‡ç¤ºå™¨
    cables.forEach((cable) => {
      if (!cable.indicatorEl || !cable.active) return

      const cablePos = cable.points[0].clone()
      cablePos.project(camera)

      const result = calculateIndicatorPosition(cablePos, 0.85, widthHalf, heightHalf)

      if (!result) {
        cable.indicatorEl.style.display = 'none'
      } else {
        cable.indicatorEl.style.display = 'block'
        cable.indicatorEl.style.left = `${result.screenX}px`
        cable.indicatorEl.style.top = `${result.screenY}px`
        cable.indicatorEl.style.transform = `translate(-50%, -50%) rotate(${-result.deg}deg)`
      }
    })
  }

  // === ä¸»å¾ªç¯ ===
  function animate(currentTime) {
    requestAnimationFrame(animate)

    if (!currentTime) currentTime = performance.now()
    const elapsed = currentTime - lastFrameTime
    if (elapsed < fpsInterval) return
    lastFrameTime = currentTime - (elapsed % fpsInterval)

    const time = clock.getElapsedTime()

    if (!gameState.isPlaying) {
      scene.rotation.y = 0
      // ä¾§å‰æ–¹è§†è§’ï¼šX=18ï¼ˆå³ä¾§ï¼‰ï¼ŒY=-20ï¼ˆä¸Šæ–¹ï¼‰ï¼ŒZ=-12ï¼ˆå‰æ–¹ï¼Œé²¨é±¼é¢å‘-Zï¼‰
      camera.position.set(10, 3, -6)
      camera.lookAt(0, -2, -2)
      renderer.render(scene, camera)
      return
    } else {
      if (gameState.isPaused) {
        renderer.render(scene, camera) // ä¿æŒæ¸²æŸ“é™æ€å¸§
        return
      }
      scene.rotation.y = 0
    }

    // 1. é²¨é±¼è¿åŠ¨é€»è¾‘ï¼ˆæ›´æ–°ï¼‰
    // ç§»åŠ¨ç«¯ä½¿ç”¨è™šæ‹Ÿæ‘‡æ†æ›´æ–°è§†è§’
    if (isMobile && joystickActive) {
      // åº”ç”¨è·ç¦»åŠ æƒçš„æ—‹è½¬é€Ÿåº¦
      sharkEuler.y -= joystickDeltaX * CONFIG.joystickSensitivity
      sharkEuler.x -= joystickDeltaY * CONFIG.joystickSensitivity

      // é™åˆ¶ä¿¯ä»°è§’
      sharkEuler.x = Math.max(-1.4, Math.min(1.4, sharkEuler.x))
    }

    const targetPitch = sharkEuler.x
    const targetYaw = sharkEuler.y

    // ä½¿ç”¨å››å…ƒæ•° Slerp è¿›è¡Œå¹³æ»‘æ—‹è½¬

    // 1.1. æ ¹æ®è¾“å…¥çš„ä¿¯ä»°è§’ï¼ˆXï¼‰å’Œåèˆªè§’ï¼ˆYï¼‰åˆ›å»ºç›®æ ‡æ¬§æ‹‰è§’
    // ä½¿ç”¨ 'YXZ' é¡ºåºï¼Œè¿™åœ¨é£è¡Œ/è‡ªç”±ç§»åŠ¨æ§åˆ¶ä¸­è¾ƒä¸ºå¸¸ç”¨
    const targetEuler = new THREE.Euler(targetPitch, targetYaw, 0, 'YXZ')
    targetRotation.setFromEuler(targetEuler)

    // 1.2. è®¡ç®—ä¾§å€¾ï¼ˆRollï¼‰
    // è·å–å½“å‰çš„åèˆªè§’å€¼ï¼ˆé€šè¿‡å°†å››å…ƒæ•°è½¬å›æ¬§æ‹‰è§’ï¼‰
    const currentEuler = new THREE.Euler().setFromQuaternion(sharkContainer.quaternion, 'YXZ')
    // è®¡ç®—ç›®æ ‡åèˆªè§’å’Œå½“å‰åèˆªè§’ä¹‹é—´çš„å·®å€¼ï¼ˆä½œä¸ºè½¬å‘é€Ÿåº¦çš„è¿‘ä¼¼ï¼‰
    const yawDelta = targetYaw - currentEuler.y

    // è®¡ç®—ç›®æ ‡ä¾§å€¾è§’ï¼šåŸºäºè½¬å‘é€Ÿåº¦ï¼ˆyawDeltaï¼‰ã€‚é™åˆ¶ä¾§å€¾å¹…åº¦åœ¨ -45åº¦ï¼ˆ0.78 radï¼‰åˆ° 45åº¦
    const targetRoll = Math.max(-0.78, Math.min(0.78, -yawDelta * 5 * CONFIG.rollFactor))

    // 1.3. å°†ä¾§å€¾ï¼ˆZè½´æ—‹è½¬ï¼‰åº”ç”¨åˆ°ç›®æ ‡å››å…ƒæ•°ä¸Š
    // åˆ›å»ºä¸€ä¸ªåªåŒ…å«ä¾§å€¾çš„å››å…ƒæ•°
    const rollQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, -1), targetRoll)
    // å°†ä¾§å€¾åˆå¹¶åˆ°ç›®æ ‡æ—‹è½¬ä¸­
    targetRotation.multiply(rollQuaternion)

    // 1.4. ä½¿ç”¨ Slerp å¹³æ»‘æ’å€¼å½“å‰çš„å››å…ƒæ•°åˆ°ç›®æ ‡å››å…ƒæ•°
    sharkContainer.quaternion.slerp(targetRotation, CONFIG.turnSpeed)

    // è€åŠ›ç³»ç»Ÿï¼šå†²åˆºæ—¶æ¶ˆè€—ï¼Œä¸å†²åˆºæ—¶æ¢å¤
    if (isBoosting && gameState.stamina > 0) {
      gameState.stamina -= CONFIG.staminaDrainRate
      if (gameState.stamina <= 0) {
        gameState.stamina = 0
        isBoosting = false // è€åŠ›è€—å°½æ—¶åœæ­¢å†²åˆº
        if (isMobile) {
          document.getElementById('sprint-button').classList.remove('active')
        }
      }
      updateHUD() // å®æ—¶æ›´æ–°è€åŠ›æ¡
    } else if (!isBoosting && gameState.stamina < CONFIG.maxStamina) {
      gameState.stamina += CONFIG.staminaRecoverRate
      if (gameState.stamina > CONFIG.maxStamina) {
        gameState.stamina = CONFIG.maxStamina
      }
      updateHUD() // å®æ—¶æ›´æ–°è€åŠ›æ¡
    }

    // å¦‚æœè€åŠ›ä¸è¶³ï¼Œå¼ºåˆ¶åœæ­¢å†²åˆº
    if (isBoosting && gameState.stamina < CONFIG.minStaminaToBoost) {
      isBoosting = false
      if (isMobile) {
        document.getElementById('sprint-button').classList.remove('active')
      }
    }

    // æ›´æ–°å†²åˆºæŒ‰é’®çŠ¶æ€ï¼ˆç§»åŠ¨ç«¯ï¼‰
    if (isMobile) {
      const sprintBtn = document.getElementById('sprint-button')
      if (gameState.stamina < CONFIG.minStaminaToBoost) {
        sprintBtn.classList.add('disabled')
      } else {
        sprintBtn.classList.remove('disabled')
      }
    }

    // å§‹ç»ˆå‘å‰ç§»åŠ¨ï¼ˆæ²¿è‡ªèº«çš„ Z è½´ï¼‰
    const currentSpeed = isBoosting ? CONFIG.boostSpeed : CONFIG.sharkSpeed
    sharkContainer.translateZ(-currentSpeed)

    // æ‘„åƒæœºè·Ÿéšï¼ˆLerpï¼‰
    let relativeCameraOffset
    let lookAtTarget

    if (isLookingBack) {
      // ä¾§å‰æ–¹: å³ 8, ä¸Š 5, å‰ 20 (Z ä¸ºè´Ÿæ˜¯å‰)
      relativeCameraOffset = new THREE.Vector3(8, 5, -20)

      // çœ‹å‘èº«å: è·å–åæ–¹å‘é‡
      const backward = new THREE.Vector3(0, 0, 1).applyQuaternion(sharkContainer.quaternion)
      lookAtTarget = sharkContainer.position.clone().add(backward.multiplyScalar(20))
    } else {
      relativeCameraOffset = new THREE.Vector3(0, 5, CONFIG.cameraDistance)

      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(sharkContainer.quaternion)
      lookAtTarget = sharkContainer.position.clone().add(forward.multiplyScalar(10))
    }

    const cameraOffset = relativeCameraOffset.applyMatrix4(sharkContainer.matrixWorld)

    camera.position.lerp(cameraOffset, 0.1)
    camera.lookAt(lookAtTarget)

    // å°¾å·´æ‘†åŠ¨
    sharkMesh.children[0].rotation.y = Math.sin(time * (isBoosting ? 20 : 8)) * 0.5

    // 2. å…‰ç¼†é€»è¾‘ä¸ç¢°æ’
    const biteRadius = 8.0

    for (let i = cables.length - 1; i >= 0; i--) {
      const cable = cables[i]
      if (!cable.active) continue

      let hit = false
      let hitPoint = null
      for (let p of cable.points) {
        if (p.distanceTo(sharkContainer.position) < biteRadius) {
          hit = true
          hitPoint = p.clone()
          break
        }
      }

      if (hit && isBoosting) {
        gameState.score += 1024
        gameState.cablesCut++
        soundManager.playCut()
        createExplosion(hitPoint) // è§¦å‘çˆ†ç‚¸ç‰¹æ•ˆ

        // æ¢å¤ç”Ÿå‘½
        gameState.health += CONFIG.recoverHealth
        if (gameState.health > CONFIG.maxHealth) {
          gameState.health = CONFIG.maxHealth
        }

        // æ¢å¤è€åŠ›
        gameState.stamina += CONFIG.recoverStamina
        if (gameState.stamina > CONFIG.maxStamina) {
          gameState.stamina = CONFIG.maxStamina
        }

        updateHUD()

        cable.mesh.material.emissive.setHex(0x000000)
        cable.mesh.material.color.setHex(0x333333)
        cable.mesh.position.y -= 1
        cable.active = false

        // éšè—å¹¶æ¸…ç†å…‰ç¼†æŒ‡ç¤ºå™¨
        if (cable.indicatorEl) {
          cable.indicatorEl.style.display = 'none'
        }
      }
    }

    // æ‰€æœ‰ç”µç¼†éƒ½è¢«åˆ‡æ–­åï¼Œé‡æ–°ç”Ÿæˆç”µç¼†ç»„
    if (cables.every((c) => !c.active)) {
      generateCables() // åŸºäºé²¨é±¼å½“å‰ä½ç½®ç”Ÿæˆ
      gameState.score += 5000
      updateHUD()
    }

    // 3. æ•Œäººé€»è¾‘
    const spawnChance = 0.01 + gameState.cablesCut * 0.002

    if (Math.random() < spawnChance) {
      spawnEnemy()
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i]

      e.group.lookAt(sharkContainer.position)
      e.group.translateZ(e.speed)

      if (e.type === 'aws') e.mesh.rotation.z += 0.1
      if (e.type === 'azure') e.mesh.rotation.x += 0.1

      const dist = e.group.position.distanceTo(sharkContainer.position)

      if (dist < 2.5) {
        takeDamage(e.damage)
        soundManager.playDamage()
        scene.remove(e.group)
        if (e.indicatorEl) e.indicatorEl.remove()
        enemies.splice(i, 1)
        continue
      }

      if (dist > CONFIG.enemyRemoveDistance) {
        scene.remove(e.group)
        if (e.indicatorEl) e.indicatorEl.remove()
        enemies.splice(i, 1)
      }
    }

    // 4. ç²’å­åŠ¨ç”»
    particles.forEach((p) => {
      // å¦‚æœç²’å­ç³»ç»Ÿç¦»é²¨é±¼å¤ªè¿œï¼Œåˆ™å°†å…¶ç§»åˆ°é²¨é±¼å‰æ–¹
      if (sharkContainer.position.distanceTo(p.position) > 200) {
        p.position.copy(sharkContainer.position)
        p.position.z -= 100
      }
      p.rotation.y += 0.001
    })

    // 5. æ›´æ–°çˆ†ç‚¸ç‰¹æ•ˆ
    for (let i = explosions.length - 1; i >= 0; i--) {
      const exp = explosions[i]
      exp.age++
      const positions = exp.mesh.geometry.attributes.position.array

      for (let j = 0; j < exp.velocities.length / 3; j++) {
        positions[j * 3] += exp.velocities[j * 3]
        positions[j * 3 + 1] += exp.velocities[j * 3 + 1]
        positions[j * 3 + 2] += exp.velocities[j * 3 + 2]
      }
      exp.mesh.geometry.attributes.position.needsUpdate = true
      exp.mesh.material.opacity = 1 - exp.age / exp.maxAge

      if (exp.age >= exp.maxAge) {
        scene.remove(exp.mesh)
        exp.mesh.geometry.dispose()
        exp.mesh.material.dispose()
        explosions.splice(i, 1)
      }
    }

    // é™ä½æŒ‡ç¤ºå™¨æ›´æ–°é¢‘ç‡ä»¥æå‡æ€§èƒ½
    indicatorUpdateCounter++
    if (indicatorUpdateCounter >= indicatorUpdateInterval) {
      updateIndicators()
      indicatorUpdateCounter = 0
    }

    renderer.render(scene, camera)
  }

  // === éŸ³æ•ˆç³»ç»Ÿ ===
  class SoundManager {
    constructor() {
      this.ctx = null
      this.masterGain = null
      this.bgmGain = null
      this.sfxGain = null
      this.bgmAudio = null
      this.noiseBuffer = null
    }

    init() {
      if (this.ctx) return
      const AudioContext = window.AudioContext || window.webkitAudioContext
      this.ctx = new AudioContext()

      this.masterGain = this.ctx.createGain()
      this.masterGain.gain.value = 1.0
      this.masterGain.connect(this.ctx.destination)

      // BGM é€šé“
      this.bgmGain = this.ctx.createGain()
      this.bgmGain.gain.value = 0.8
      this.bgmGain.connect(this.masterGain)

      this.bgmAudio = new Audio('bgm.mp3')
      this.bgmAudio.loop = true
      // ä½¿ç”¨ MediaElementSource é€šè¿‡ Web Audio API è·¯ç”±éŸ³é¢‘å…ƒç´ 
      const bgmSource = this.ctx.createMediaElementSource(this.bgmAudio)
      bgmSource.connect(this.bgmGain)

      // éŸ³æ•ˆé€šé“
      this.sfxGain = this.ctx.createGain()
      this.sfxGain.gain.value = 0.8
      this.sfxGain.connect(this.masterGain)

      this.noiseBuffer = this.createNoiseBuffer()
    }

    createNoiseBuffer() {
      const bufferSize = this.ctx.sampleRate * 2 // 2 ç§’
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate)
      const data = buffer.getChannelData(0)
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1
      }
      return buffer
    }

    playBGM() {
      if (this.bgmAudio && this.ctx) {
        if (this.ctx.state === 'suspended') {
          this.ctx.resume()
        }
        this.bgmAudio.play().catch((e) => console.error(e))
      }
    }

    setBGMVolume(val) {
      if (this.bgmGain && this.ctx) {
        this.bgmGain.gain.setValueAtTime(val, this.ctx.currentTime)
      }
      // åŒæ—¶ç›´æ¥åœ¨éŸ³é¢‘å…ƒç´ ä¸Šè®¾ç½®éŸ³é‡ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
      if (this.bgmAudio) {
        this.bgmAudio.volume = val
      }
    }

    setSFXVolume(val) {
      if (this.sfxGain) {
        this.sfxGain.gain.setValueAtTime(val, this.ctx.currentTime)
      }
    }

    playTone(freq, type, duration, startTime = 0, vol = 1) {
      if (!this.ctx) return
      const osc = this.ctx.createOscillator()
      const gain = this.ctx.createGain()
      osc.type = type
      osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime)
      gain.gain.setValueAtTime(vol, this.ctx.currentTime + startTime)
      gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration)
      osc.connect(gain)
      gain.connect(this.sfxGain) // è¿æ¥åˆ°éŸ³æ•ˆå¢ç›Š
      osc.start(this.ctx.currentTime + startTime)
      osc.stop(this.ctx.currentTime + startTime + duration)
    }

    createOscillator(type, freqStart, freqEnd, gainStart, duration) {
      const now = this.ctx.currentTime
      const osc = this.ctx.createOscillator()
      const gain = this.ctx.createGain()
      osc.type = type
      osc.frequency.setValueAtTime(freqStart, now)
      osc.frequency.exponentialRampToValueAtTime(freqEnd, now + duration)
      gain.gain.setValueAtTime(gainStart, now)
      gain.gain.exponentialRampToValueAtTime(0.01, now + duration)
      osc.connect(gain)
      gain.connect(this.sfxGain)
      osc.start(now)
      osc.stop(now + duration)
    }

    playBoost() {
      if (!this.ctx) return
      this.createOscillator('sawtooth', 60, 30, 0.5, 0.4)
      this.createOscillator('square', 300, 150, 0.2, 0.2)
      this.createOscillator('triangle', 800, 400, 0.2, 0.1)
    }

    playCut() {
      // çˆ†ç‚¸éŸ³æ•ˆ
      if (!this.ctx || !this.noiseBuffer) return
      const source = this.ctx.createBufferSource()
      source.buffer = this.noiseBuffer
      const gain = this.ctx.createGain()

      // ä½é€šæ»¤æ³¢ï¼Œæ¨¡æ‹Ÿçˆ†ç‚¸çš„æ²‰é—·æ„Ÿ
      const filter = this.ctx.createBiquadFilter()
      filter.type = 'lowpass'
      filter.frequency.setValueAtTime(600, this.ctx.currentTime)
      filter.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 1)

      source.connect(filter)
      filter.connect(gain)
      gain.connect(this.sfxGain)

      gain.gain.setValueAtTime(1.0, this.ctx.currentTime)
      gain.gain.exponentialRampToValueAtTime(0.2, this.ctx.currentTime + 1)

      source.start()
      source.stop(this.ctx.currentTime + 1)
    }

    playDamage() {
      this.playTone(150, 'square', 0.3, 0, 0.5)
      this.playTone(100, 'sawtooth', 0.4, 0, 0.5)
    }

    playGameOver() {
      this.playTone(300, 'triangle', 0.5, 0)
      this.playTone(250, 'triangle', 0.5, 0.4)
      this.playTone(200, 'triangle', 1.0, 0.8)
    }
  }

  const soundManager = new SoundManager()

  init()
</script>
</body>
</html>
